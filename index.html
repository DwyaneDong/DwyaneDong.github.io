<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  

  
  <title>DongXuehui&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="I am willing to do anything but ordinary.">
<meta property="og:type" content="website">
<meta property="og:title" content="DongXuehui&#39;s Blog">
<meta property="og:url" content="http://dongxh.cn/index.html">
<meta property="og:site_name" content="DongXuehui&#39;s Blog">
<meta property="og:description" content="I am willing to do anything but ordinary.">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="DongXuehui&#39;s Blog">
<meta name="twitter:description" content="I am willing to do anything but ordinary.">
  
    <link rel="alternate" href="/atom.xml" title="DongXuehui&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>
</html>
<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">DongXuehui&#39;s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://dongxh.cn"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-OS-处理器管理（4）-线程及其实现" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/03/OS-处理器管理（4）-线程及其实现/" class="article-date">
  <time datetime="2020-04-03T13:10:44.000Z" itemprop="datePublished">2020-04-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Operating-System/">Operating System</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/03/OS-处理器管理（4）-线程及其实现/">OS--处理器管理（4）_线程及其实现</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="OS—处理器管理（4）-线程及其实现"><a href="#OS—处理器管理（4）-线程及其实现" class="headerlink" title="OS—处理器管理（4）_线程及其实现"></a>OS—处理器管理（4）_线程及其实现</h1><p>知识点：</p>
<ul>
<li>引入多线程的动机</li>
<li>多线程环境中的进程和线程</li>
<li>线程的实现</li>
</ul>
<h2 id="引入多线程的动机"><a href="#引入多线程的动机" class="headerlink" title="引入多线程的动机"></a>引入多线程的动机</h2><p>在引入进程的概念后，又引入线程的概念，目的是为了减少程序并发执行时所付出的时空开销，使得并发颗粒更细，并发性更好。</p>
<p>引入线程的基本思路是：把进程的两项功能<strong>独立分配资源</strong>和<strong>被调度分派执行</strong>分离开来。</p>
<p><strong>独立分配资源</strong>：任由进程完成，作为系统资源分配和保护的独立单位，无须频繁切换。</p>
<p><strong>被调度分派执行</strong>：交给称为线程的实体来完成，线程作为系统调度和分派的基本单位，会被频繁地调度和切换。</p>
<p><strong>多线程结构进程的优点：</strong></p>
<ol>
<li>快速线程切换。同一进程中的多线程切换只需要改变堆栈和寄存器，地址空间不变。</li>
<li>通信易于实现。自动共享进程的内存和文件，线程可自由访问全局数据，实现数据共享十分方便，线程通信相对简单不必经过内核。</li>
<li>减少管理开销。线程创建和撤销工作比进程少很多，并且无须再分配存储空间和各种资源。</li>
<li>并发程度提高。</li>
</ol>
<h2 id="多线程环境中的进程和线程"><a href="#多线程环境中的进程和线程" class="headerlink" title="多线程环境中的进程和线程"></a>多线程环境中的进程和线程</h2><h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><p>系统调度的基本单位是线程而不是进程,每当创建一个进程时，至少要同时为该进程创建一个线程</p>
<p>多线程环境下线程和进程：</p>
<p><img src="1.png" style="zoom: 45%;"></p>
<p>多进程结构进程结构示意图：</p>
<p>进程分为<strong>资源集合</strong>和<strong>线程集合</strong>。进程要支撑线程运行，为线程提供虚拟地址空间和各种资源。</p>
<p>进程封装管理信息，包括对指令代码、全局数据、打开的文件和信号量等共享部分的管理。</p>
<p>线程封装执行信息，包括状态信息、寄存器、执行栈（用户栈指针与核心栈指针）和局部变量、过程调用参数，返回值等私有部分的管理。</p>
<p><img src="2.png" style="zoom:60%;"></p>
<p>也把线程称为轻量进程（Light Weight Process, LWP）。</p>
<h4 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h4><p>线程状态有运行，就绪，等待和终止，线程的状态转换与进程类似。</p>
<p>由于线程不是资源拥有单位，挂起状态对于线程是没有意义的。挂起操作所引起的状态是进程级状态。</p>
<p>如果进程挂起后被对换出主存，则它的所有线程因共享进程的地址空间，也必须全部对换出去。</p>
<h4 id="线程组织"><a href="#线程组织" class="headerlink" title="线程组织"></a>线程组织</h4><p>一个进程可以包含若干线程，线程有多种组织方式：</p>
<ol>
<li>调度员-工作者模式：进程中的一个线程担任调度员、接收和处理工作请求，其他线程是工作者线程，由调度员线程分配任务并处理工作请求。</li>
<li>组模式：进程中的各个线程都可以取得并处理工作请求，有时某个线程被设计成专门执行特点任务，并建立相应任务队列。</li>
<li>流水线模式：线程排成某个次序，第一线程所生产的数据传给下一个线程进行处理，依次类推，数据按照排定次序由线程依次传递以完成被请求的任务</li>
</ol>
<h2 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h2><p>多线程的实现分为三类：</p>
<ol>
<li>用户级线程（User Level Thread , ULT）</li>
<li>内核级线程（Kernel Level Thread , KLT）</li>
<li>混合式线程，同时支持ULT和KLT</li>
</ol>
<h4 id="用户级线程ULT"><a href="#用户级线程ULT" class="headerlink" title="用户级线程ULT"></a>用户级线程ULT</h4><p>由用户应用程序建立、调度和管理的线程。(如Java ，Informix)</p>
<ol>
<li>不依赖于OS内核，应用进程利用<strong>线程库</strong>提供创建、同步、调度和管理线程的函数来控制用户线程。</li>
<li>调度由应用软件内部进行，通常采用非抢先式和更简单的规则，也无需用户态/核心态切换，所以速度特别快。一个线程发起系统调用而阻塞，则整个进程在等待。时间片分配给进程，多线程则每个线程就慢。</li>
</ol>
<p><strong>线程库</strong>：基于多线程的应用程序的开发和运行环境。</p>
<p>内核不知道线程的活动，但仍然管理线程所属进程的活动；当线程调用系统调用时，整个进程阻塞；但对线程库来说，线程仍然是运行状态，即线程状态是与进程状态独立的。</p>
<p>优点：</p>
<ul>
<li>线程切换不调用内核</li>
<li>调度是应用程序特定的：可以选择最好的算法。</li>
<li>ULT可运行在任何操作系统上（只需要线程库）。</li>
</ul>
<p>缺点：</p>
<ul>
<li>大多数系统调用是阻塞的，因此核心阻塞进程，故进程中所有线程将被阻塞。</li>
<li>核心只将处理器分配给进程，同一进程中的两个线程不能同时运行于两个处理器上，因此不能利用多处理器优点</li>
</ul>
<h4 id="内核级线程KLT"><a href="#内核级线程KLT" class="headerlink" title="内核级线程KLT"></a>内核级线程KLT</h4><p>由操作系统的内核建立、调度和管理的线程。(如Windows NT，OS/2)</p>
<ul>
<li>所有线程管理由内核完成</li>
<li>没有线程库，但对内核线程工具提供API</li>
<li>内核维护进程和线程的上下文</li>
<li>线程之间的切换需要内核支持</li>
<li>以线程为基础进行调度</li>
</ul>
<p>优点：</p>
<ul>
<li>对多处理器，内核可以同时调度同一进程的多个线程</li>
<li>阻塞是在线程一级完成</li>
<li>内核例程是多线程的</li>
</ul>
<p>缺点：</p>
<ul>
<li>线程在用户态运行，而线程的调度和管理在内核实现，则在同一个进程中，控制权要想从一个线程转送到另一个线程时需要用户态-内核态-用户态模式转换，系统开销大</li>
</ul>
<h4 id="KLT和ULT比较"><a href="#KLT和ULT比较" class="headerlink" title="KLT和ULT比较"></a>KLT和ULT比较</h4><p><img src="3.png" style="zoom:100%;"></p>
<h4 id="混合式线程"><a href="#混合式线程" class="headerlink" title="混合式线程"></a>混合式线程</h4><p>线程实现分为两个层次：用户级和核心级。线程创建在用户空间完成；大量线程调度和同步在用户空间完成；程序员可以调整KLT的数量；可以取两者中最好的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://dongxh.cn/2020/04/03/OS-处理器管理（4）-线程及其实现/" data-id="ck8l56qhj000htmlktjf1639u" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/操作系统/">操作系统</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-OS-处理器管理（3）-进程及其实现" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/02/OS-处理器管理（3）-进程及其实现/" class="article-date">
  <time datetime="2020-04-02T08:17:21.000Z" itemprop="datePublished">2020-04-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Operating-System/">Operating System</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/02/OS-处理器管理（3）-进程及其实现/">OS--处理器管理（3）_进程及其实现</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="OS—处理器管理（3）-进程及其实现"><a href="#OS—处理器管理（3）-进程及其实现" class="headerlink" title="OS—处理器管理（3）_进程及其实现"></a>OS—处理器管理（3）_进程及其实现</h1><p>知识点：</p>
<ul>
<li>进程定义和属性</li>
<li>进程状态和转换</li>
<li>进程描述和组成</li>
<li>进程上下文切换与处理器状态转换</li>
<li>进程控制和管理</li>
</ul>
<h2 id="进程的定义和属性"><a href="#进程的定义和属性" class="headerlink" title="进程的定义和属性"></a>进程的定义和属性</h2><p>“进程“是操作系统中最重要最基本的概念，在多道程序系统提出后，为了刻画系统内部动态状况，描述运行程序活动规律而提出的新概念。</p>
<p>从<strong>原理角度</strong>来看，进程是支持程序执行的一种系统机制，是对处理器上运行程序的活动规律的抽象；</p>
<p>从<strong>现实角度</strong>看，进程是一种数据结构，用来准确刻画运行程序的状态和系统动态变化状况；</p>
<p>引入进程的两个目的：</p>
<ol>
<li>刻画程序的并发性；</li>
<li>解决资源的共享性<br>“可再入”程序指的是能够被多个程序同时调用的程序；“可再用”程序是指在被调用的过程中可以有自身修改，在调用它的程序退出之前不允许其他程序来调用。</li>
</ol>
<p>引入进程的概念后，程序与程序的执行（计算)不再一一对应。</p>
<p><strong>定义：进程是既能描述程序的并发执行，又能共享系统调用资源的一个基本单位。</strong>（操作系统要为引入进程而付出（进程占用的）空间和（进程调度的）时间的代价）。<strong>进程是具有独立功能的程序在某个数据集合上的一次运行活动，也是操作系统进行资源分配和保护的基本单位</strong>。</p>
<p>进程的属性：</p>
<ol>
<li>动态性。<br>因为进程是一次执行过程，具有生命周期，具有动态概念。</li>
<li>共享性。<br>同义程序同时运行在不同的数据集合上时构成不同进程，即多个不同进程可执行相同的程序。</li>
<li>独立性<br>每个进程是操作系统中的一个独立实体，有自己的虚存空间，程序计数器和内部状态。</li>
<li>制约性<br>进程因为共享资源或者协同工作产生相互制约关系，造成进程执行速度的不可预测性，必须对进程的执行次序或相对执行速度加以协调。</li>
<li>并发性<br>进程在时间上可以重叠，单处理器系统中并发执行，多处理器系统中可以并行执行。</li>
</ol>
<h2 id="进程的状态和转换"><a href="#进程的状态和转换" class="headerlink" title="进程的状态和转换"></a>进程的状态和转换</h2><h4 id="三态模型"><a href="#三态模型" class="headerlink" title="三态模型"></a>三态模型</h4><p>正如上面所说的，由于进程的动态性，为了便于管理，我们按照进程在执行过程中的不同情况，至少给其定义三种进程状态：</p>
<ol>
<li>运行态（running）：进程占有处理器正在运行的状态</li>
<li>就绪态（ready）：进程具备运行条件，等待系统分配处理器以便运行的状态</li>
<li>等待态（wait）：又称阻塞态（blocked）或者睡眠态（sleep），指进程不具备运行条件，正在等待某个事件完成的状态。</li>
</ol>
<p>处于运行态的进程个数不能大于处理器个数。</p>
<p><img src="1.png" style="zoom:50%;"></p>
<h4 id="七态模型"><a href="#七态模型" class="headerlink" title="七态模型"></a>七态模型</h4><p>有时为了便于管理，会引进新的状态：</p>
<ol>
<li>新建态（new）：进程被创建时的状态，尚未进入就绪队列。</li>
<li>终止态（exit）：进程完成任务到达正常结束点，或者出现无法克服的错误而异常终止，或被操作系统及有终止权的进程所终止时所处的状态。不再被调度，等待被撤销。</li>
<li>挂起态（suspend）：当系统资源尤其是内存资源已经不能满足进程运行的要求时，必须把某些进程挂起，<strong>对换到磁盘对换区中</strong>，释放占用的某些资源，暂时不参与低级调度，还有很多原因，</li>
</ol>
<p><img src="2.png" style="zoom:50%;"></p>
<p>挂起就绪态（ready suspend）表明进程具备运行条件，但目前在外存中，只有当它被对换到内存才能被调度执行；</p>
<p>挂起等待态（blocked suspend）表明进程正在等待某一个事件发生且也在外存中。</p>
<p>在一个实际的操作系统中，为了方便管理和调度往往设置多种进程状态。如Linux主要的进程状态有5种。</p>
<h2 id="进程的描述和组成"><a href="#进程的描述和组成" class="headerlink" title="进程的描述和组成"></a>进程的描述和组成</h2><h4 id="进程映像"><a href="#进程映像" class="headerlink" title="进程映像"></a>进程映像</h4><p><img src="3.png" style="zoom:40%;"></p>
<ul>
<li>进程映像：进程某时刻的内容和状态集合。<ul>
<li>进程控制块：存储进程标志信息、现场信息和控制信息。</li>
<li>进程程序块：被进程执行的程序。</li>
<li>进程核心栈：用来保存中断/异常现场，保存内核函数调用的参数、局部变量和返回地址。</li>
<li>进程数据块：进程的私有地址空间，存放各种私有数据，包括用户栈。</li>
</ul>
</li>
</ul>
<p>进程上下文（process context）：进程物理实体和支持进程运行的环境。如硬件寄存器、程序状态字寄存器、支持动态地址转换的页表和相关的核心数据结构。</p>
<p>当系统调度新进程占有处理器时，新老进程随之发生上下文切换。进程的运行被认为是在上下文中执行。</p>
<p>进程上下文组成：</p>
<ol>
<li>用户级上下文（user level context）：由程序块、数据块、共享内存区、用户栈组成，占用进程的虚存空间。</li>
<li>系统级上下文（register context）：有进程控制块、内存管理信息、核心栈等操作系统管理进程所需要的信息组成。</li>
<li>寄存器上下文（system level context）：由处理器状态寄存器、指令计数器、栈指针、通用寄存器等组成。</li>
</ol>
<h4 id="进程控制块"><a href="#进程控制块" class="headerlink" title="进程控制块"></a>进程控制块</h4><p>每个进程有且仅有一个程序控制块（Process Control Block , PCB）,或称进程描述符（process descriptor），是进程存在的唯一标识。是操作系统用于记录和刻画进程状态及有关信息的数据结构。也是操作系统掌握进程的唯一资料结构，它包括进程执行时的情况，以及进程让出处理器后所处的状态、断点等信息。</p>
<p>PCB包含以下三类信息</p>
<ol>
<li>标识信息。用于唯一地标识一个进程，分为用户使用的外部标识符和系统使用的内部标识号。</li>
<li>现场信息。用于保留进程在运行时存放在处理器现场中的各种信息。</li>
<li>控制信息。用于管理和调度进程。</li>
</ol>
<p><strong>PCB是操作系统中最重要的数据结构，它包含管理进程所需要的全部信息。</strong></p>
<p>PCB的集合实际上定义了一个操作系统当前的状态，其使用权和修改权均属于操作系统。操作系统根据PCB对并发执行的进程进行控制和管理，进程借助于PCB才能被调度执行。</p>
<h4 id="进程队列及其管理"><a href="#进程队列及其管理" class="headerlink" title="进程队列及其管理"></a>进程队列及其管理</h4><p>把<strong>处于同一状态</strong>的所有进程的PCB链接在一起的数据结构称为<strong>进程队列（process queue）</strong>。通常有两种组织队列的方式：</p>
<p><strong>链接方式</strong></p>
<p>对于同一状态进程的PCB，通过PCB中的链接指针将其链接成队列，单向指针和双向指针都可以。单向队列编号为0排在队尾；双向队列对于后向指针来说编号为0在队尾，对于前向指针，编号为0在前面</p>
<p>不同状态的进程可以排成不同的队列，如运行队列，就绪队列和等待队列等。运行队列通常只有一个进程；就绪队列可以按照优先级或者FCFS（First Come First Serve）的原则排队，也可以按照进程的优先级高低分成多个就绪队列；等待队列通常有多个，对应不同的等待状态，如等待I/O操作完成，等待信号量等。此外还可以将空闲PCB结构链接成自由队列以便使用。</p>
<p>当某个事件发生，状态发生改变时，有个进程会出队，有的进程会进队。处理器调度中负责进程入队和出队工作的功能模块称为<strong>队列管理模块</strong>，其任务就是对进程的PCB重新排队并修改其状态和相应链接结构。</p>
<p><img src="4.png" style="zoom:50%;"></p>
<p><strong>索引方式</strong></p>
<p>索引方式利用索引表记录不同状态进程的PCB地址或者在PCB表中的编号，系统建立不同状态的索引表，各个索引表在内存中的起始位置放在内核占用指针单元中。</p>
<p><img src="5.png" style="zoom:50%;"></p>
<h2 id="进程上下文切换于处理器状态转换"><a href="#进程上下文切换于处理器状态转换" class="headerlink" title="进程上下文切换于处理器状态转换"></a>进程上下文切换于处理器状态转换</h2><h4 id="进程上下文切换"><a href="#进程上下文切换" class="headerlink" title="进程上下文切换"></a>进程上下文切换</h4><p><strong>中断和异常是激活操作系统的仅有方法。</strong>这里说的激活操作系统的意思是指让操作系统内核获得处理器控制权，也就是进入内核态。因为只有操作系统有权利使用修改进程PCB，所以<strong>进程切换必定发生在内核态而非用户态</strong>。</p>
<p><img src="6.png" style="zoom:50%;"></p>
<p>思考题：程序状态字PSW和进程控制块PCB的区别？</p>
<p><strong>进程上下文切换时机</strong></p>
<p>内核中不能立即进行调度和切换的情况有：内核正在处理中断的过程中，进程运行在内核临界区中，内核处在需要屏蔽中断的原子操作中。</p>
<p>如果在上述过程中产生引起调度的条件而不能马上进行调度和切换，系统采用将请求调度标志延迟到敏感性操作完成后再进行。</p>
<p>为此，Linux在进程<code>task_struct</code>中设计了重调度标志<code>need_resched</code>,V２.６版中，被移至<code>thread_info</code> 结构体中，用标志<code>TIF_NEED_RESCHED</code> 表示 。调度时机：</p>
<ol>
<li>主动调度：指调用<code>schedule()</code>函数来释放CPU,引起新一轮调度，通常发生在当前进程状态被改变,如:执行了<code>read()</code>、<code>write()</code>、<code>exit()</code>等系统调用，导致进程终止、进程阻塞等。</li>
<li>被动调度：指发生了引起调度的条件, 这时仅置进程<code>TIF_NEED_RESCHED</code>调度标志。调度标志设置有以下四种情况：<ol>
<li>时钟中断中调用函数<code>scheduler_tick()</code>，查看当前进程的时间片是否耗尽，如果是，则设置重调度标志；</li>
<li>函数<code>try_to_wake_up( )</code>将阻塞的进程唤醒，把它加入运行队列时，如果其优先级比当前正在运行进程的优先级高，设置重调度标志。</li>
<li>设置应用进程优先级参数nice值、创建新进程、SMP负载均衡时都可能使高优先级进程进入就绪状态，也可能设置重调度标志；</li>
<li>执行<code>sched_setscheduler( )</code>（设置调度策略）、<code>sched_yield</code>( 暂时让出处理器)、<code>pause( )</code>（暂停）等系统调用，均要设置重调度标志。</li>
</ol>
</li>
</ol>
<p>每当中断处理和系统调用处理结束返回时，在<code>ret_from_sys_call</code>代码段中会主动测试调度标志，若置位则调用<code>schedule()</code>函数.</p>
<h4 id="处理器状态转换"><a href="#处理器状态转换" class="headerlink" title="处理器状态转换"></a>处理器状态转换</h4><p>步骤：</p>
<ol>
<li>保存被中断进程的处理器现场信息；</li>
<li>处理器从用户态转换到核心态，以便执行服务程序或中断处理程序；</li>
<li>如果处理中断，可根据规定的中断级设置中断屏蔽位；</li>
<li>根据系统调用号或中断号，从系统调用表或中断入口表找到服务程序或中断处理程序地址。</li>
</ol>
<p>处理器上执行进程的活动范围必在以下四个情况下：</p>
<ol>
<li>用户空间中，处于进程上下文，用户进程在运行，使用用户栈。</li>
<li>内核空间中，处于进程上下文，内核代表某进程在运行，使用核心栈。</li>
<li>内核空间中，处于中断上下文，与任何进程无关，中断服务程序正在处理特定中断，Intel x86未提供中断栈，借用核心栈。</li>
<li>内核空间中，内核线程(无用户地址空间的进程)运行于内核态。</li>
</ol>
<h4 id="Linux中进程上下文切换"><a href="#Linux中进程上下文切换" class="headerlink" title="Linux中进程上下文切换"></a>Linux中进程上下文切换</h4><p><img src="7.png" style="zoom:50%;"></p>
<h2 id="进程控制和管理"><a href="#进程控制和管理" class="headerlink" title="进程控制和管理"></a>进程控制和管理</h2><p>原语是在操作系统中调用核心层子程序的指令。与一般广义指令的区别在于它是<strong>不可中断</strong>的，而且总是作为一个基本单位出现。它与一般过程的区别在于：它们是“原子操作”（primitive or atomic action）。所谓原子操作，是指一个操作中的所有动作要么全做，要么全不做。换言之，它是一个不可分割的基本单位，因此，在执行过程中不允许被中断。<strong>原子操作在管态下执行，常驻内存</strong>。原语的作用是为了实现进程的通信和控制，系统对进程的控制如不使用原语，就会造成其状态的不确定性，从而达不到进程控制的目的</p>
<p>进程管理原语</p>
<h4 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h4><ol>
<li>在进程列表中增加一项，从PCB池中申请一个空闲PCB，为新进程分配惟一的进程标识符；</li>
<li>为新进程的进程映像分配地址空间，以便容纳进程实体。进程管理程序确定加载到进程地址空间中的程序；</li>
<li>为新进程分配除主存空间外的其他各种所需资源；</li>
<li>初始化PCB，如进程标识符、处理器初始状态、进程优先级等；</li>
<li>把新进程状态置为就绪态，并移入就绪进程队列；</li>
<li>通知操作系统的某些模块，如记账程序、性能监控程序。</li>
</ol>
<h4 id="进程撤销"><a href="#进程撤销" class="headerlink" title="进程撤销"></a>进程撤销</h4><ol>
<li>根据撤销进程标识号，从相应队列中找到并移出它；</li>
<li>将该进程拥有的资源归还给父进程或操作系统；</li>
<li>若该进程拥有子进程，先撤销它的所有子进程，以防它们脱离控制；</li>
<li>回收PCB，并归还到PCB池。</li>
</ol>
<h4 id="进程阻塞"><a href="#进程阻塞" class="headerlink" title="进程阻塞"></a>进程阻塞</h4><ol>
<li>停止进程执行，保存现场信息到PCB；</li>
<li>修改进程PCB有关内容，如进程状态由运行态改为等待态等，并把修改状态后的进程移入相应事件的等待队列中；</li>
<li>转入进程调度程序去调度其他进程运行。</li>
</ol>
<h4 id="进程唤醒"><a href="#进程唤醒" class="headerlink" title="进程唤醒"></a>进程唤醒</h4><ol>
<li>从相应的等待队列中移出进程；</li>
<li>修改进程PCB的有关信息，如进程状态改为就绪态，并移入就绪队列；</li>
<li>若被唤醒进程比当前运行进程优先级高，重新设置调度标志。</li>
</ol>
<h4 id="进程的挂起"><a href="#进程的挂起" class="headerlink" title="进程的挂起"></a>进程的挂起</h4><ol>
<li>检查要被挂起的进程的状态</li>
<li>若处于活动就绪态，则修改为挂起就绪态</li>
<li>若处于等待态，则修改为挂起等待态</li>
<li>被挂起的进程PCB的非常驻部分要交换到磁盘对换区</li>
</ol>
<h4 id="进程的激活"><a href="#进程的激活" class="headerlink" title="进程的激活"></a>进程的激活</h4><ol>
<li>把被挂起进程PCB的非常驻部分掉入内存</li>
<li>修改为对应的状态（等待或者就绪）</li>
<li>将进程移入相应队列中</li>
</ol>
<p>挂起原语既可由自己也可由其他进程调用，而激活原语只能由其他进程调用。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://dongxh.cn/2020/04/02/OS-处理器管理（3）-进程及其实现/" data-id="ck8l56qju000ytmlk2l2hj39p" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/操作系统/">操作系统</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-OS-处理器管理（1）-中断技术" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/30/OS-处理器管理（1）-中断技术/" class="article-date">
  <time datetime="2020-03-30T14:40:52.000Z" itemprop="datePublished">2020-03-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Operating-System/">Operating System</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/30/OS-处理器管理（1）-中断技术/">OS--处理器管理（2）_中断技术</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="OS—处理器管理-2-中断技术"><a href="#OS—处理器管理-2-中断技术" class="headerlink" title="OS—处理器管理(2)_中断技术"></a>OS—处理器管理(2)_中断技术</h1><p>知识要点：</p>
<ul>
<li>中断概念</li>
<li>中断源分类</li>
<li>中断和异常的响应及服务</li>
<li>中断事件处理原则</li>
<li>中断优先级和多重中断</li>
<li>Linux中断处理（自学）</li>
</ul>
<h3 id="中断概念"><a href="#中断概念" class="headerlink" title="中断概念"></a>中断概念</h3><p>每当应用程序执行系统调用时要求获得系统服务，I/O设备报告传输情况，或者产生各种内部外部事件时，都要通过中断机制产生中断信号并启动操作系统内核工作。<strong>操作系统是由“中断驱动”的。</strong></p>
<p><strong>中断（interrupt）</strong>指在程序执行过程中遇到急需处理的事件时，暂时中止现行程序在CPU上的运行，转而执行相应的事处理程序，待处理完成后再返回断点或者调度其他程序执行的过程。</p>
<p><strong>共性</strong>：即中断装置能够改变处理器内操作的执行顺序。</p>
<p><strong>中断系统</strong>：</p>
<ul>
<li>中断装置：指发现中断，响应中断的硬件<ul>
<li>发现中断源，提出中断请求；</li>
<li>保护现场 ；</li>
<li>启动处理中断事件的程序 ；</li>
</ul>
</li>
<li>中断处理程序：由软件来完成<ul>
<li>主要任务是处理中断事件和恢复正常操作 ；</li>
</ul>
</li>
</ul>
<h3 id="中断源分类"><a href="#中断源分类" class="headerlink" title="中断源分类"></a>中断源分类</h3><p><img src="1.png" style="zoom:50%;"></p>
<p>外中断：各个中断具有不同的中断优先级，表示事件的紧急程度，在处理高一级的中断时，往往会屏蔽部分或者全部的低级中断。</p>
<p>内中断：不能被屏蔽，一旦出现应立即予以响应并进行处理。</p>
<p>​        外中断和内中断组合形成完整的中断体系，由于产生原因和处理方法差别越来越大，所以把中断和异常区分开来：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>中断</th>
<th>异常</th>
</tr>
</thead>
<tbody>
<tr>
<td>由与当前运行程序无关的中断信号触发，CPU对中断的响应是被动的，无论CPU处于什么状态，都需要处理外部设备发来的中断请求</td>
<td>由CPU控制单元产生，允许指令在执行期间响应异常，大部分异常发生在用户态，而内核态唯一发生的异常是‘缺页异常’</td>
</tr>
<tr>
<td>要求中断被快速处理，以便及时响应其他中断信号，所以中断处理程序处理过程中是不能被阻塞的</td>
<td>异常处于被打断的当前进程上下文中，所提供的服务是当前进程所需要的，异常处理程序处理过程中是可以被阻塞的</td>
</tr>
<tr>
<td>中断允许发生嵌套</td>
<td>异常大多为一重</td>
</tr>
<tr>
<td>中断处理过程中决不会被异常打断</td>
<td>异常处理过程中可能会产生中断</td>
</tr>
</tbody>
</table>
</div>
<h3 id="中断和异常的响应及服务"><a href="#中断和异常的响应及服务" class="headerlink" title="中断和异常的响应及服务"></a>中断和异常的响应及服务</h3><p>无论中断还是异常，CPU的响应过程基本上是一致的，即在执行完当前指令后，根据中断源所提供的“中断向量”，在内核中找到相应的中断服务例程并调度执行。</p>
<p>1.中断向量由硬件或者操作系统预先分配和设置；2.系统调用对应的向量则在访管指令中给出；3.异常向量在CPU的硬件结构预先规定；</p>
<p>发现中断源并产生中断的硬件称为<strong>中断控制器</strong>，包括中断逻辑线路和中断寄存器。再看异常，它是执行指令时，由于指令本身的原因发生的，指令的控制逻辑和实现线路一旦发现异常便转向内核的异常处理程序。</p>
<p>中断/异常的响应需要顺序做四件事：</p>
<p><img src="2.png" style="zoom:50%;"></p>
<h3 id="中断事件处理原则"><a href="#中断事件处理原则" class="headerlink" title="中断事件处理原则"></a>中断事件处理原则</h3><p><strong>硬件故障处理</strong>：需要人工干预</p>
<p><strong>程序性中断</strong>：一是语法错误，由编译程序发现并报错；二是逻辑错误，由测试程序发现；三是程序运行过程中产生异常。</p>
<p><strong>I/O中断</strong></p>
<p>I/O中断的处理原则如下：</p>
<ol>
<li>I/O操作正常结束。把等待传输的下一个进程设置为就绪态，让它占据设备或者通道并启动数据传输。</li>
<li>I/O操作发生故障。先向设备发命令索取状态字，分析产生故障的确切原因，再进行复执或者请求人工干预。</li>
<li>I/O操作发生异常。分析情况采取相应的措施，向操作员报告。</li>
<li>设备报到或者设备结束。表示有设备接入可供使用或者设备断开暂停使用，操作系统应该修改系统数据结构中相应的设备状态。</li>
</ol>
<p><strong>访管中断</strong></p>
<p>由程序执行访管指令而引起的，表示当前运行程序对操作系统功能的调用，可看做机器指令的一种扩充。</p>
<p>访管指令包括操作码和访管参数两部分，前者表示此指令是访管指令，后者表示具体的访管要求。</p>
<p>。。。</p>
<p><strong>时钟中断</strong></p>
<p>​        时钟是操作系统进行调度工作的重要工具。比如让分时进程作时间片轮转；让实时进程定时发出或接收控制信号；系统定时唤醒或阻塞一个进程；对用户进程进行记账。</p>
<p>​        时钟可分成绝对时钟和间隔时钟两种。</p>
<p>​        有了硬件定时器，Linux就可以统计用户的记账信息，它记录了进程的创建时间以及进程在生命周期占用的CPU时间，每个时钟滴答到来时，核心都修改当前进程在内核态和用户态占用的时间。</p>
<p>​        Linux系统运行不同的间隔定时器，类型有三种：</p>
<ul>
<li>real间隔定时器：按实际经过时间计时，不管进程处在何种模式下运行，包括进程被挂起时，计时总在进行，定时到达时发送给进程一个SIGALRM信号。</li>
<li>virtual间隔定时器：进程在用户态下执行时才计时，定时到达时发送给进程一个SIGVTALRM信号。</li>
<li>profile间隔定时器：进程执行在用户态或核心态时都计时，当定时到达时发送给进程一个SIGROF信号。</li>
</ul>
<h3 id="中断优先级和多重中断"><a href="#中断优先级和多重中断" class="headerlink" title="中断优先级和多重中断"></a>中断优先级和多重中断</h3><p><strong>中断优先级</strong></p>
<p>有硬件方法和软件方法实现：硬件方法，根据排定的优先级顺序做一个硬件链式排队器，当产生高一级中断事件时，应该屏蔽比它优先级低的所有中断源；软件方法，编写一个查询程序，根据优先级顺序从高到低进行查询，一旦发现有中断请求便转入相应的中断时间处理程序的入口。</p>
<p><strong>中断屏蔽</strong></p>
<p>可由CPU通过指令编写中断控制器的屏蔽码来实现。</p>
<p>中断屏蔽是指禁止CPU相应中断或者禁止中断产生。</p>
<p>作用是：</p>
<ol>
<li>延迟或禁止某些中断的响应。系统程序执行过程中，不希望产生干扰事件，以免共享数据结构受到破坏。程序运行过程中产生某些事件认为是正常的，不必加以处理。</li>
<li>协调中断响应与中断处理的关系。确保高优先级中断可以打断低优先级中断，反之却不能。</li>
<li>防止同级中断相互干扰。在处理某优先级中断事件时，必须屏蔽该级中断，以免造成混乱。</li>
</ol>
<p><strong>多重中断事件处理</strong></p>
<p>中断正在进行处理期间，CPU又响应新的中断事件，于是暂时停止正在运行的中断处理程序，转去执行新的中断处理程序，就叫多重中断（又称中断嵌套）。</p>
<p>对同一优先级的不同中断：采用顺序处理 方法。</p>
<p>对不同优先级的中断，采用以下处理方法：1.串行处理；2.嵌套处理，还要规定最大嵌套重数；3.即时处理，在运行中断处理程序时，如果出现程序性中断事件，在一般情况下，表明此时中断处理程序有异常，应对其立即响应并进行处理</p>
<h3 id="Linux中断处理"><a href="#Linux中断处理" class="headerlink" title="Linux中断处理"></a>Linux中断处理</h3><p><img src="3.png" style="zoom: 45%;"></p>
<h5 id="Linux中断机制"><a href="#Linux中断机制" class="headerlink" title="Linux中断机制"></a><strong>Linux中断机制</strong></h5><p><strong>中断向量</strong>：对中断信号编码，每个中断信号的编码称为其对应的中断向量；</p>
<p>中断请求：每个能发送中断信号的硬件设备控制器都有一根控制线，与中断控制器相连接，若是硬件欲向CPU发送                   中断信号必须申请一条可用的中断请求线，或者说一个IRQ号，这就是中断请求（Interrupt                                                 Requirement，IRQ）。</p>
<p><strong>中断描述符表</strong>：Linux中断机制在保护模式下采用中断描述符表（Interrupt Descriptor Table,IDT）实现，此表包                          含256个表项，每个中断/异常都对应一个表项，每个表项称为一个门描述符（gate descriptor）,                          作用是把程序控制权转交给中断/异常处理程序。门的含义是，当中断/异常发生时必须先通过这                          道门，才能进入中断/异常处理程序。</p>
<p><img src="4.png" style="zoom:40%;"></p>
<p><strong>中断请求队列</strong>：</p>
<ol>
<li>中断处理程序和中断服务例程</li>
<li>中断处理程序的执行</li>
</ol>
<p>中断共享的数据结构为irqaction。</p>
<p><strong>中断处理程序的执行</strong></p>
<h5 id="Linux下半部分处理"><a href="#Linux下半部分处理" class="headerlink" title="Linux下半部分处理"></a>Linux下半部分处理</h5><p>中断处理程序的特点是：以异步方式运行，有可能打断关键代码的执行，甚至打断处理程序的执行；运行时屏蔽中断，最坏的情况会屏蔽所有中断；要操作硬件，对时限要求很高；在中断上下文运行，故不能被阻塞。总之，需要中断处理程序执行的越快越好，因为<strong>缩短屏蔽中断的时间对于系统的响应能力和性能都至关重要</strong>。</p>
<p><img src="5.png" style="zoom: 40%;"></p>
<h5 id="Linux的三种任务延迟机制"><a href="#Linux的三种任务延迟机制" class="headerlink" title="Linux的三种任务延迟机制"></a>Linux的三种任务延迟机制</h5><ol>
<li>小任务（tasklet）</li>
<li>工作队列（work queue）</li>
<li>软中断（softirq）</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://dongxh.cn/2020/03/30/OS-处理器管理（1）-中断技术/" data-id="ck8l56qjp000wtmlkjug8xfq1" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/操作系统/">操作系统</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-OS-处理器管理（1）-处理器状态" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/28/OS-处理器管理（1）-处理器状态/" class="article-date">
  <time datetime="2020-03-28T07:13:22.000Z" itemprop="datePublished">2020-03-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Operating-System/">Operating System</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/28/OS-处理器管理（1）-处理器状态/">OS--处理器管理（1）_处理器状态</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="OS—处理器管理-1-处理器状态"><a href="#OS—处理器管理-1-处理器状态" class="headerlink" title="OS—处理器管理(1)_处理器状态"></a>OS—处理器管理(1)_处理器状态</h1><p>要点：</p>
<ul>
<li>处理器</li>
<li>程序字状态</li>
</ul>
<h3 id="处理器"><a href="#处理器" class="headerlink" title="处理器"></a>处理器</h3><h4 id="指令系统和寄存器"><a href="#指令系统和寄存器" class="headerlink" title="指令系统和寄存器"></a>指令系统和寄存器</h4><p>计算机中最终被执行的是存储在内存中的机器指令代码。</p>
<p>处理器根据程序计数器的指向从内存中取指令到指令寄存器，然后译码并执行，程序计数器自动增长或变为转移地址以指明下一条待执行指令的地址。</p>
<p>每台计算机的机器指令集称为<strong>指令系统</strong>，反映计算机的功能和处理能力。</p>
<ul>
<li>数据处理类指令：用于执行算术和逻辑运算。 </li>
<li>I/O类指令：用于启动外围设备，让主存和设备交换数据。 </li>
<li>寄存器数据交换类指令：用于在处理器的寄存器和存储器之间交换数据。 </li>
<li>转移类指令：用于改变执行指令序列。</li>
<li>处理器控制指令：修改处理器状态，改变处理器工作方式。</li>
</ul>
<p>以Intel x86为例：</p>
<ul>
<li>通用寄存器：                                $EAX ,EBX,ECX,EDX$.</li>
<li>指针及变址寄存器：                    $ESP,EBP,ESI,EDI$.</li>
<li>段选择符寄存器：                        $CS,DS,SS,ES,FS,GS$.</li>
<li>指令指针寄存器和标志寄存器：$EIP,EFLAGS$.</li>
<li>控制寄存器：                               $CRO,CR1,CR2,CR3$.</li>
<li>外部设备使用的寄存器。</li>
</ul>
<p><strong>问题：在单道程序系统中，用户程序可以直接使用CPU指令启动I/O设备，进行I/O操作。在多道程序系统中，这种模式可不可行？</strong></p>
<h4 id="特权指令和非特权指令"><a href="#特权指令和非特权指令" class="headerlink" title="特权指令和非特权指令"></a>特权指令和非特权指令</h4><p><strong>特权指令</strong>：只仅能在内核态下才能使用的指令，这些指令涉及改变机器状态，修改寄存器内容，启动设备I/O等。</p>
<p><strong>非特权指令</strong>：在管态和目态下都能执行。（</p>
<p>操作系统程序能运行全部机器指令，应用程序只能使用非特权指令。</p>
<p>当应用程序试图执行特权指令，将会导致非法执行二产生的保护中断，继而转向操作系统的“用户非法执行特权指令”的异常处理程序处理。</p>
<h4 id="内核态和用户态"><a href="#内核态和用户态" class="headerlink" title="内核态和用户态"></a>内核态和用户态</h4><p>处理器状态标志：管理状态（核心状态、特态或管态）和用户状态（目标状态、常态或目态)。</p>
<p>Intel x86处理器状态有4种，0级权限最高，3级权限最低。</p>
<h4 id="处理器状态及其转换"><a href="#处理器状态及其转换" class="headerlink" title="处理器状态及其转换"></a>处理器状态及其转换</h4><p>在下列三种情况下会导致处理器状态从用户态向内核态转变：</p>
<ol>
<li>程序请求操作系统服务，执行系统调用</li>
<li>程序运行时产生中断事件（如I/O操作完成），运行程序被中断，转向中断处理程序执行</li>
<li>程序运行时产生异常事件（如发生程序性中断，或目态执行特权指令），运行程序被打断，转向异常处理程序工作</li>
</ol>
<p>而从内核态向用户态转换，则通过一条称为加载程序状态字的特权指令（Intel x86为iret指令）</p>
<h4 id="用户栈和核心栈"><a href="#用户栈和核心栈" class="headerlink" title="用户栈和核心栈"></a>用户栈和核心栈</h4><p>用户栈：用户进程空间中开辟的一块区域，用于保护应用程序的子程序（子函数）之间互相调用的参数，返回值，返回点以及子程序的局部变量</p>
<p>核心栈：也称内核栈或系统栈。是内存中属于操作系统空间的一块区域。</p>
<p>核心栈的用途：</p>
<ol>
<li>保护中断现场，对于嵌套中断，被中断程序的现场信息依次压入核心栈，中断返回时逆序弹出；</li>
<li>保存操作系统程序（函数）间相互调用的参数，返回值，返回点以及程序局部变量。</li>
</ol>
<p>每个进程被创建时捆绑一个核心栈，具有可读可写不可执行属性。</p>
<p>栈指针：为硬件栈指针，用户栈和核心栈共用一个栈指针。</p>
<h3 id="程序状态字"><a href="#程序状态字" class="headerlink" title="程序状态字"></a>程序状态字</h3><p>$Program Status Word,PSW$ 程序状态字。PSW用来<strong>控制指令执行顺序</strong>并<strong>保留和指示与程序有关的系统状态和各种信息</strong>，主要作用是实现程序状态的保护和恢复。每个正在执行的程序都有一个与其当前状态相关的PSW，每个处理器都设置一个PSW寄存器。程序占有处理器执行，它的PSW将占有PSW寄存器。</p>
<p>操作系统将程序运行时的一组<strong>动态信息</strong>汇集在一起。并存放在处理器的一组特殊寄存器里面，以方便系统控制和管理。</p>
<p>$PSW$寄存器包括以下内容：</p>
<ul>
<li>程序基本状态：<ul>
<li>程序计数器；</li>
<li>条件码；</li>
<li>处理器状态位；</li>
</ul>
</li>
<li>中断码。保存程序执行时当前发生的中断事件。</li>
<li>中断屏蔽位。指明程序执行中发生中断事件时，是否响应出现的中断事件。</li>
</ul>
<p>在Intel x86机器中，$PSW$由标志寄存器$EFLAGS$和指针寄存器$EIP$组成，均为32位。$EFLAGS$低16位称为$FLAGS$，可以当作一个单元来处理。指令指针寄存器$EIP$的低16位称为$IP$（保护模式需使用32位），可以当作一个单元使用，存放顺序执行的下一条指令相对于当前代码段起始地址的一个偏移量。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://dongxh.cn/2020/03/28/OS-处理器管理（1）-处理器状态/" data-id="ck8l56qhf000etmlkvxxsy76h" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/操作系统/">操作系统</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-OS-操作系统概论" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/27/OS-操作系统概论/" class="article-date">
  <time datetime="2020-03-27T14:15:32.000Z" itemprop="datePublished">2020-03-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Operating-System/">Operating System</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/27/OS-操作系统概论/">OS--操作系统概论</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Operating-System—操作系统概论"><a href="#Operating-System—操作系统概论" class="headerlink" title="Operating System—操作系统概论"></a>Operating System—操作系统概论</h1><p>知识要点：</p>
<ul>
<li>操作系统的定义</li>
<li>操作系统资源管理技术：复用，虚拟，抽象</li>
<li>抽象：三个基本抽象—进程，虚存，文件</li>
<li>虚拟：虚拟机</li>
<li>复用：多道程序设计</li>
</ul>
<p>了解：</p>
<ul>
<li>操作系统的历史，分类，常见的操作系统</li>
<li>操作系统接口，操作系统服务</li>
</ul>
<hr>
<h3 id="一、计算机系统的软硬件层次结构"><a href="#一、计算机系统的软硬件层次结构" class="headerlink" title="一、计算机系统的软硬件层次结构"></a>一、计算机系统的软硬件层次结构</h3><ul>
<li>硬件层</li>
<li>系统软件（操作系统）层<ul>
<li>将硬件封装，调度分配资源，存取保护信息，协调控制并发等</li>
<li>隔离硬件&amp;软件，提供接口，共性服务，运行环境</li>
</ul>
</li>
<li>支撑软件层<ul>
<li>利用操作系统提供的扩展指令集，实现编译程序，汇编程序，语言处理程序，窗口系统，数据库管理系统等。</li>
</ul>
</li>
<li>应用软件层<ul>
<li>不同邻域，不同需求的软件</li>
</ul>
</li>
</ul>
<p>支撑软件&amp;应用软件通过OS来使用计算机系统的物理资源。</p>
<h4 id="操作系统定义"><a href="#操作系统定义" class="headerlink" title="操作系统定义"></a>操作系统定义</h4><p>管理系统资源、控制程序执行、改善人机界面、提供各种服务，并合理组织计算机工作流程和为用户方便有效地使用计算机提供良好运行环境的一种系统软件。</p>
<h4 id="操作系统功能与特性"><a href="#操作系统功能与特性" class="headerlink" title="操作系统功能与特性"></a>操作系统功能与特性</h4><p>操作系统中，能分配给用户使用的硬件和软件设施总称为资源，包括两类：硬件资源和信息资源。</p>
<p>硬件资源：处理器，存储器，I/O设备等；</p>
<p>信息资源：程序和数据等；</p>
<h4 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h4><p><img src="5.png" alt></p>
<h4 id="操作系统特性"><a href="#操作系统特性" class="headerlink" title="操作系统特性"></a>操作系统特性</h4><p><strong>并发性：</strong></p>
<p>采用并发技术的系统称多任务系统。实现并发技术的关键之一是如何对系统内的多个活动(进程)进行切换的技术。并行性是并发性的特例，而并发性是并行性的扩展。</p>
<p><strong>共享性：</strong></p>
<p>指操作系统中的资源可被多个并发执行的进程所使用。</p>
<p>透明资源共享：资源隔离与授权访问</p>
<p>显式（独占）资源共享：临界资源与独占访问</p>
<p><strong>虚拟性</strong>：</p>
<p>一个物理实体映射为若干个对应的逻辑实体－－分时或分空间。虚拟是OS管理系统资源的重要手段，可提高资源利用率；</p>
<p><strong>异步性：</strong></p>
<p>指系统中的各种事件的发生具有随机性。异步性给系统带来潜在危险，有可能导致与时间有关的错误。操作系统的一个重要任务是必须确保捕捉任何一种随机事件，正确处理可能发生的随机事件，正确处理任何一种产生的事件序列，否则将会导致严重后果。</p>
<h4 id="操作系统学习总纲"><a href="#操作系统学习总纲" class="headerlink" title="操作系统学习总纲"></a>操作系统学习总纲</h4><p><img src="1.png" style="zoom: 50%;"></p>
<h3 id="二、资源管理技术"><a href="#二、资源管理技术" class="headerlink" title="二、资源管理技术"></a>二、资源管理技术</h3><ul>
<li>资源复用（解决物理资源不足）<ul>
<li>空分复用共享（space-multiplexed sharing）：内存和外存；</li>
<li>时分复用共享（time-multiplexed sharing）：时分独占式（磁带），时分共享式（CPU，磁盘机）；</li>
</ul>
</li>
<li>资源虚拟（解决物理资源不足，提高服务能力和水平）<ul>
<li>资源转化，模拟或整合技术。可将物理上的一个资源变成逻辑上的多个对应物（或者物理上多个变成逻辑上一个）空分复用分割实际存在的物理资源，虚拟实现虚构假想的虚拟同类资源。</li>
</ul>
</li>
<li>资源抽象（处理系统复杂性，解决资源的易用性）<ul>
<li>通过创建软件来屏蔽硬件资源的物理特性和接口细节，简化对硬件资源的操作，控制和使用的一类技术。</li>
</ul>
</li>
<li>组合使用</li>
</ul>
<h3 id="三、基础抽象——进程抽象，虚存抽象和文件抽象"><a href="#三、基础抽象——进程抽象，虚存抽象和文件抽象" class="headerlink" title="三、基础抽象——进程抽象，虚存抽象和文件抽象"></a>三、基础抽象——进程抽象，虚存抽象和文件抽象</h3><p><img src="2.png" style="zoom:50%;"></p>
<h4 id="进程抽象"><a href="#进程抽象" class="headerlink" title="进程抽象"></a>进程抽象</h4><p>进程是对进入内存的执行程序在处理器上操作的状态集的一个抽象。</p>
<p>进程抽象的效果是让用户感觉到有自己独享的处理器，从而可为用户提供多任务操作系统和分时操作系统。</p>
<h4 id="虚存抽象"><a href="#虚存抽象" class="headerlink" title="虚存抽象"></a>虚存抽象</h4><p>虚存抽象的效果是给用户造成假象，感觉独占了一个连续地址空间，编写应用程序的长度不受物理内存大小限制。</p>
<p>虚存是通过结合对内存和外存的管理来实现的，把一个进程的虚存中的内容存储在磁盘上，用内存作为磁盘的高速缓存，以此为用户提供比物理内存空间大得多的虚拟内存空间。</p>
<h4 id="文件抽象"><a href="#文件抽象" class="headerlink" title="文件抽象"></a>文件抽象</h4><p>文件是通过将文件中的字节映射到存储设备的物理块中来实现文件抽象。</p>
<p>文件抽象的效果是让用户感觉到总能满足自己对设备上信息的存取需求，而且使用十分方便。</p>
<p><img src="3.png" style="zoom: 33%;"></p>
<h4 id="其他资源抽象"><a href="#其他资源抽象" class="headerlink" title="其他资源抽象"></a>其他资源抽象</h4><p>操作系统还对其他底层硬件资源抽象，如中断，时钟，网络接口等。值得注意的是，资源抽象也可以用于没有特定基础硬件的软件资源，如消息，信号量和共享数据结构等。对象和抽象数据类型是常用于创建抽象资源的软件机制。</p>
<h3 id="四、操作系统虚拟机"><a href="#四、操作系统虚拟机" class="headerlink" title="四、操作系统虚拟机"></a>四、操作系统虚拟机</h3><p>不同于程序虚拟机，操作系统虚拟机等于裸机加操作系统；</p>
<p>操作系统虚拟机的组成：虚处理器，虚拟内存，虚拟外存，虚拟设备。</p>
<p><img src="4.png" style="zoom: 50%;"></p>
<h3 id="五、多道程序设计"><a href="#五、多道程序设计" class="headerlink" title="五、多道程序设计"></a>五、多道程序设计</h3><p>​        单道程序设计处理器在工作时效率不高的原因，是因为，在现代计算机系统中，I/O操作较慢而CPU运行速度快，故程序运行时花费在I/O操作上的时间最多。</p>
<p>​        而程序在执行I/O操作时，CPU是空闲的。并且传统计算机配备有许多I/O设备，只有一个CPU。</p>
<p>​        所以为了提高效率工程师们就设计，让计算机可以同时接受多个程序。当一个设备等待设备进行数据传输时，让其他的程序运行，以缩短CPU的空闲等待时间，提高CPU的利用率。</p>
<p>下面给出一道例题，方便理解这一过程（忽略丑字）：</p>
<p><img src="6.png" alt></p>
<p>​        具有cpu和设备并行能力的计算机采用多道程序设计技术后，可以提高CPU和设备的并行性，从而提高系统吞吐率，即增加了单位时间内完成计算题目的数量。</p>
<p>​        </p>
<p>​        在多道程序设计中，我们需要特别关注一点，就是道数的多少。</p>
<p>​        表面上，似乎道数越多效率越高。但是道数的具体数目，往往受到系统资源的限制。内存的容量和用户的响应时间等因素都会影响多道程序的道数。</p>
<p>​        采用概率论的方法计算CPU的利用率：</p>
<p>​        假设程序平均等待I/O操作的时间占其运行时间的比例为$p$，当内存中有$n$道程序时，所有程序都等待I/O操作的概率为$p^n$，即此时CPU是空闲的，那么CPU利用率：</p>
<script type="math/tex; mode=display">
Utilization \ of\ CPU = 1-p^n</script><p>​        其中n称为多道程序的道数或者度数（degree of multiprogramming）</p>
<p><img src="7.png" style="zoom:50%;"></p>
<p><strong>总结：</strong></p>
<p>优点：1.提高CPU，内存和设备的利用率；2.提高系统的吞吐率，使单位时间内完成的作业数量增加；3.可以充分发挥系统的并行性，是设备与设备之间，CPU与设备之间均可并行工作。</p>
<p>缺点：延长了作业的周转时间。</p>
<p>​        多道程序设计与<strong>多重处理系统（multiprocessing system）</strong>存在差别，后者配置多个物理处理器，可以真正同时执行。</p>
<p>​        实现$multiprogramming$必须解决三个问题：</p>
<ol>
<li><p>存储保护和程序浮动</p>
<p>在多道程序设计环境中，内存为多道程序共享，需有相应措施避免相互干扰，这就是<strong>存储保护</strong>。因为各程序不是独占全机内存，甚至运行中程序可能随时更改位置，所以要求程序能根据需要从一个内存区移动到另一个区，而不影响正常执行，这称为<strong>程序浮动或地址重定位</strong>。</p>
</li>
<li><p>处理器管理与分配</p>
<p>设计cpu调度和分配，以及多道程序切换和有效运行，还有合理搭配不同特性的程序。</p>
</li>
<li><p>资源管理与调度</p>
<p>其他资源均需按照一定策略来分配和调度，解决竞争与协作，共享与安全，及各个资源的利用率问题</p>
</li>
</ol>
<h3 id="六、操作系统服务与接口"><a href="#六、操作系统服务与接口" class="headerlink" title="六、操作系统服务与接口"></a>六、操作系统服务与接口</h3><p>主要（方便编程）的<strong>共性服务</strong>：<strong>编写和执行程序</strong>，<strong>数据I/O和信息存取</strong>，<strong>进程通信服务</strong>，<strong>差错检测和处理</strong>。</p>
<p>用户接口：</p>
<p><img src="8.png" style="zoom: 33%;"></p>
<p>​        程序接口：是os对外提供服务和功能的手段，由一组<strong>系统调用（System call）</strong>组成。</p>
<p>​        操作接口：由一组控制命令和（或）作业控制语言组成，是操作系统为用户提供的组织和控制其作业（应用                            程序）执行的手段。</p>
<h4 id="程序接口与系统调用"><a href="#程序接口与系统调用" class="headerlink" title="程序接口与系统调用"></a>程序接口与系统调用</h4><h5 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h5><p><strong>操作系统内核（kernel）</strong>提供一系列具有预定功能的服务例程（标准程序），通过一组称为<strong>系统调用（System call）</strong>的接口呈现给用户，系统调用把应用程序的请求传送至内核，调用相应服务例程完成所需处理，将处理结果返回给应用程序。</p>
<p>程序的运行空间分为<strong>内核空间</strong>和<strong>用户空间</strong>。系统调用目的除了提供共性接口服务，还有就是分隔内核空间与用户空间，程序按照不同的特权运行，在逻辑上相互隔离，使得应用程序不能直接访问内核数据，想要获得系统服务，必须通过系统调用。</p>
<p>CPU在系统调用中的状态变化：</p>
<p><img src="9.png" style="zoom: 45%;"></p>
<p>作用：</p>
<ol>
<li>内核可以基于权限和规则对资源访问进行裁决，保证系统的安全性</li>
<li>系统调用对资源进行抽象，提供一致性接口，避免用户在使用资源时发生错误，且使得编程效率大大提高</li>
</ol>
<h5 id="API，库函数和系统调用"><a href="#API，库函数和系统调用" class="headerlink" title="API，库函数和系统调用"></a>API，库函数和系统调用</h5><p>每种操作系统所提供的系统调用集不同，若是应用程序直接使用系统调用，一接口复杂，使用困难，二应用程序跨平台可移植性受到限制。为此IEEE提出了POSIX（Portable Operating System Interface）标准，为不同平台下的应用程序提供相同的API（Application Program Interface）, UNIX/Linux都遵循POSIX标准。</p>
<p><img src="10.png" style="zoom: 33%;"></p>
<h5 id="系统调用分类"><a href="#系统调用分类" class="headerlink" title="系统调用分类"></a>系统调用分类</h5><p><img src="11.png" style="zoom: 50%;"></p>
<h5 id="系统调用实现"><a href="#系统调用实现" class="headerlink" title="系统调用实现"></a>系统调用实现</h5><p>​        操作系统实现系统调用功能的机制称为陷阱或者异常处理机制。</p>
<p>​        由于系统调用而引起的处理器中断的机器指令称为访管指令（supervisor），自陷指令（trap）或者中断指令（interrupt），其中访管指令为非特权指令，在用户态（目态）下执行时会将CPU转换到内核态。</p>
<p>​        系统调用<strong>实现的要点</strong>：</p>
<p>​            1.编写系统调用服务例程；</p>
<p>​            2.设计系统调用入口地址表。每个入口地址都指向一个系统调用服务例程；</p>
<p>​            3.陷阱处理机制，需要开辟现场保护区，以保存发生系统调用时应用程序的处理器现场</p>
<p><img src="12.png" style="zoom:50%;"></p>
<p>​        <strong>参数传递</strong>也是实现过程中需要解决的问题，不同的系统调用要向相应的内核服务例程传递不同的参数，执行系统调用的结果也要以参数形式返回给应用程序。</p>
<p>实现参数传递的方法有：</p>
<ol>
<li>访管指令或者自陷指令自带参数，在之后的若干单元存放参数（直接参数），或在紧邻的单元中存放参数的地址（间接参数）</li>
<li>通过CPU的通用寄存器传递参数，但是不适合大量参数，改良方法就是用寄存器传递参数在内存中的首地址</li>
<li>在内存中开辟专用堆栈区传递参数</li>
</ol>
<h5 id="系统调用和函数调用的区别"><a href="#系统调用和函数调用的区别" class="headerlink" title="系统调用和函数调用的区别"></a>系统调用和函数调用的区别</h5><ol>
<li>调用形式和实现方法不同</li>
<li>被调用的代码的位置不同</li>
<li>提供方式不同</li>
</ol>
<h4 id="操作接口与系统程序"><a href="#操作接口与系统程序" class="headerlink" title="操作接口与系统程序"></a>操作接口与系统程序</h4><h5 id="作业控制方式"><a href="#作业控制方式" class="headerlink" title="作业控制方式"></a>作业控制方式</h5><p><strong>作业</strong>是用户提交给操作系统计算的一个独立任务。</p>
<p><strong>作业接口</strong>是操作系统为用户操作控制计算机工作和提供服务的手段集合，通常可借助操作控制命令、图形操作界面(命令)、以及作业控制语言(命令)等来实现</p>
<p>作业接口：</p>
<p>​        联机作业控制接口：用于交互型作业处理</p>
<p>​        脱机作业控制接口：需要对作业进行控制和干预，事先写在说明书上，然后作业连同作业说明书一起提交给操作系统</p>
<h5 id="命令解释程序"><a href="#命令解释程序" class="headerlink" title="命令解释程序"></a>命令解释程序</h5><p>​        用户通过操作命令，会话语言或者作业控制命令调用命令解释程序，其功能是接受用户输入的命令并解释执行命令。系统保存一张命令动词表，其中记录着所有操作命令及其处理程序的入口地址。</p>
<h5 id="Linux命令解释程序shell"><a href="#Linux命令解释程序shell" class="headerlink" title="Linux命令解释程序shell"></a>Linux命令解释程序shell</h5><p>Linux系统提供给用户的命令语言解释程序shell，它不是操作系统的组成部分，却体现了许多操作系统的特性。</p>
<p>shell在用户态下运行。下图是shell的执行流程：</p>
<p><img src="13.png" style="zoom:45%;"></p>
<h5 id="系统程序"><a href="#系统程序" class="headerlink" title="系统程序"></a>系统程序</h5><p>系统程序又称为实用程序（Utilities）或支撑程序。虽非操作系统的核心，但却必不可少，为用户程序的开发、调试、执行、和维护解决带有共性的问题或执行公共操作。</p>
<p>支撑程序的分类：文件管理；状态信息；程序设计语言支持；程序的装入和执行支持；通信；其它软件工具。</p>
<h3 id="七、操作系统结构和运行模型"><a href="#七、操作系统结构和运行模型" class="headerlink" title="七、操作系统结构和运行模型"></a>七、操作系统结构和运行模型</h3><p>操作系统结构设计有三层含义：</p>
<ol>
<li>研究操作系统的整体结构，如功能如何分块，模块间如何交互，并要考虑构造的过程和方法；</li>
<li>研究操作系统的局部结构，包括数据结构和控制结构；</li>
<li>研究操作系统运行模型，也就是操作系统自身程序如何组织和运行；</li>
</ol>
<h4 id="操作系统结构分类"><a href="#操作系统结构分类" class="headerlink" title="操作系统结构分类"></a>操作系统结构分类</h4><h5 id="单体式结构"><a href="#单体式结构" class="headerlink" title="单体式结构"></a>单体式结构</h5><p>采用模块组合法，是基于结构化程序设计的一种软件结构设计方法。</p>
<p>主要设计思路和步骤为：把整个模块作为操作系统的基本单位，按照功能需要而不是根据程序和数据的特性首先把整个程序分解成若干模块，每个模块具有一定独立功能，若干个关联模块协作完成某个功能，明确各个模块之间的接口关系，各个模块间可以不加控制自由调控，所以又叫做<strong>无序调用法</strong>；数据多数作为全程量使用；模块之间需要传递参数或返回结果时，其个数和方式也可以根据需要随意约定；然后分别设计，编码，调试各个模块；最后，把所有模块连接成一个完整的单体系统。</p>
<p>缺点：模块独立性差，模块牵连甚多，形成复杂的调用关系，甚至有循环调用，造成系统结构不清晰，正确性难以保证，可靠性降低，系统功能的增、删、改困难。随着规模扩大，复杂度迅速增长。</p>
<h5 id="层次式结构"><a href="#层次式结构" class="headerlink" title="层次式结构"></a>层次式结构</h5><p>这种结构把操作系统划分为内核和若干模块（进程），这些模块（进程）按照功能的调用次序排列成若干层次。各层之间只能存在单向依赖或单向调用关系，即<strong>低层为高层服务</strong>。</p>
<p>缺点：由于是分层单向依赖的，必须建立模块（进程）间的通信机制，系统花费在通信上的开销较大，就这一点来说，系统效率也会降低。</p>
<p>下图为一个例子：</p>
<p><img src="14.png" style="zoom: 33%;"></p>
<h5 id="虚拟机结构"><a href="#虚拟机结构" class="headerlink" title="虚拟机结构"></a>虚拟机结构</h5><p>基于以下思想：物理计算机资源通过多重化和共享技术可以改造成多个虚拟机。</p>
<p>基本做法：通过一类物理设备来模拟另一类物理设备，或者通过分时地使用一类物理设备，把一个物理实体改造成若干个逻辑上的对应物。虚拟机监控程序CP向上层提供了若干虚拟计算机（实际物理计算机的逻辑复制品）。其虚拟化和共享硬件的做法是，每个用户终端<strong>分时</strong>使用处理器，<strong>空分</strong>使用磁盘。</p>
<h5 id="微内核结构"><a href="#微内核结构" class="headerlink" title="微内核结构"></a>微内核结构</h5><p><img src="15.png" style="zoom: 67%;"></p>
<p>操作系统仅将必需的核心放入内核，称为微内核（microkernel），其它功能都在内核之外，由在用户态运行的服务进程实现，通过微内核所提供的消息传递机制完成进程间的消息通信。</p>
<p>实现思想：将系统分为两个部分，一是运行在内核态的内核，提高系统基本功能，只完成极少内核态任务；二是运行在用户态并以客户-服务器方式执行的进程层，操作系统其它部分由相对独立的若干服务器进程来实现。用户进程也在这一层运行，由于进程具有不同的虚拟地址空间，用户和服务器进程之间采用<strong>消息传递机制</strong>进行通信，而内核被映射到所有进程的虚拟地址空间内，故可以控制所有进程。</p>
<p>缺点：运行效率较低，因为进程之间必须通过内核的通信机制才能通信。</p>
<h4 id="介绍Linux操作系统的结构设计"><a href="#介绍Linux操作系统的结构设计" class="headerlink" title="介绍Linux操作系统的结构设计"></a>介绍Linux操作系统的结构设计</h4><p>Linux系统架构</p>
<p><img src="18.png" style="zoom:50%;"></p>
<p><img src="16.png" style="zoom: 50%;"></p>
<p>引入加载模块和卸载模块机制可以一定程度上解决了单体式结构的功能适应性，灵活性和可伸缩性问题。</p>
<p><strong>Linux内核：</strong></p>
<p><img src="17.png" style="zoom:45%;"></p>
<p>由以下几个成分组成，进程调度，进程管理和进程通信，虚存管理和内存管理，VFS（虚拟文件系统）和文件管理，设备管理和设备驱动，网络管理和网络驱动等。核心是进程调度，所有的子系统大都依赖于它。</p>
<p>其他的依赖关系如下：</p>
<p><img src="19.png" style="zoom:48%;"></p>
<p><img src="20.png" style="zoom:48%;"></p>
<h4 id="操作系统内核"><a href="#操作系统内核" class="headerlink" title="操作系统内核"></a>操作系统内核</h4><p>通常把组成操作系统的基本单位称为<strong>构件</strong>。不论何种操作系统，内核都是不可缺少的构件。</p>
<h5 id="内核的概念"><a href="#内核的概念" class="headerlink" title="内核的概念"></a>内核的概念</h5><p>内核(kernel)是作为可信软件来提供支持进程并发执行的基本功能和基本操作的一组程序模块。驻留在内核空间，运行于内核态，能直接访问硬件设备和所有内存空间的权限，是仅有的能够执行特权指令的程序。</p>
<p>单内核（又称宏内核）和微内核。</p>
<p><img src="21.png" style="zoom:43%;"></p>
<h5 id="内核功能"><a href="#内核功能" class="headerlink" title="内核功能"></a>内核功能</h5><p>中断处理，时钟管理，短程调度，原语管理。</p>
<h5 id="内核的属性"><a href="#内核的属性" class="headerlink" title="内核的属性"></a>内核的属性</h5><p>内核是由中断驱动的 ；内核是不可抢占的；内核可以在屏蔽中断状态下执行；内核可以使用特权指令 。</p>
<p>内核是操作系统对裸机的第一次改造，内核和裸机组成了第一层虚拟机。</p>
<h5 id="机制与策略分离原则"><a href="#机制与策略分离原则" class="headerlink" title="机制与策略分离原则"></a>机制与策略分离原则</h5><p>Separation of mechanism and policy</p>
<h4 id="操作系统运行模型"><a href="#操作系统运行模型" class="headerlink" title="操作系统运行模型"></a>操作系统运行模型</h4><p>Linux和UNIX系统调用的服务例程均采用嵌入应用进程中执行的模型。</p>
<p><img src="22.png" style="zoom:50%;"></p>
<p>独立进程执行模式。</p>
<p><img src="23.png" style="zoom:50%;"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://dongxh.cn/2020/03/27/OS-操作系统概论/" data-id="ck8l56qn50014tmlkju5a83sl" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/操作系统/">操作系统</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-频域滤波实验报告" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/26/频域滤波实验报告/" class="article-date">
  <time datetime="2020-03-26T07:25:01.000Z" itemprop="datePublished">2020-03-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Digital-Image-Process/">Digital Image Process</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/26/频域滤波实验报告/">频域滤波实验报告</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="频域滤波实验报告"><a href="#频域滤波实验报告" class="headerlink" title="频域滤波实验报告"></a>频域滤波实验报告</h1><h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><p>1.对一幅原始图像分别做理想、巴特沃斯、高斯低通滤波及高通滤波处理，对比实验效果。</p>
<p>2.对一幅原始图像通过高频增强滤波增强图像。</p>
<h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><h3 id="实验题一"><a href="#实验题一" class="headerlink" title="实验题一"></a>实验题一</h3><p>频域滤波Matlab基本步骤：</p>
<p><img src="1.png" style="zoom:67%;"></p>
<ol>
<li><p>使用函数<code>paddesize</code>获得填充参数</p>
<p><code>PQ = paddesize(size(f));</code></p>
</li>
<li><p>得到使用填充的傅里叶变换</p>
<p><code>F = fft2(f, PQ(1), PQ(2));</code></p>
</li>
<li><p>使用本章讨论的任意一个方法，生成一个大小为$PQ(1)\times PQ(2)$的滤波函数$H$。该滤波函数的格式必须如下图b所示。另外，如果它若图a所示，则在使用该滤波器前，需要令<code>H = fftshift(H);</code></p>
<p><img src="2.png" style="zoom:50%;"></p>
</li>
<li><p>将变换乘以滤波函数</p>
<p><code>G = H.*F;</code></p>
</li>
<li><p>获得G的傅里叶逆变换实部</p>
<p><code>g = real(ifft(G));</code></p>
</li>
<li><p>将左上部的矩形修建为原始尺寸大小</p>
<p><code>g = g( 1:size(f, 1), 1:size(f, 2) );</code></p>
</li>
</ol>
<p><strong>！！步骤2，步骤567可以用以下的函数dftfilt()代替！！</strong></p>
<p>代码：</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%%主函数main.m</span></span><br><span class="line"><span class="comment">%注:下面主函数中的tofloat() ,dftuv() ,paddedsize() ,dftfilt() ,lpfilter() ,hpfilter()函数皆</span></span><br><span class="line"><span class="comment">%为数字图像处理（Matlab版），Gonzalez*书中的代码，会在附录中给出.</span></span><br><span class="line"></span><br><span class="line">clc;</span><br><span class="line">clear;</span><br><span class="line">f = imread(<span class="string">'1.png'</span>);</span><br><span class="line">PQ = paddedsize(<span class="built_in">size</span>(f)); <span class="comment">%获得填充参数 步骤一</span></span><br><span class="line">D0 = <span class="number">0.05</span>*PQ(<span class="number">1</span>);         <span class="comment">%截止频率取以填充尺寸的图像垂直尺寸的5%</span></span><br><span class="line">n = <span class="number">2</span>;                   <span class="comment">%the order n of Butterworth lowpass filter</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%步骤二，使用填充参数进行傅里叶变换，在函数dftpilt里面已经实现，而且用的填充参数并不是我们</span></span><br><span class="line"><span class="comment">%直接算出来的，而是用滤波器的长宽来计算的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%生成滤波器，生成的滤波器是未中心化的滤波器，步骤三</span></span><br><span class="line">lpi = lpfilter(<span class="string">'ideal'</span>, PQ(<span class="number">1</span>), PQ(<span class="number">2</span>), D0);   <span class="comment">%理想低通</span></span><br><span class="line">lpb = lpfilter(<span class="string">'btw'</span>, PQ(<span class="number">1</span>), PQ(<span class="number">2</span>), D0, n);  <span class="comment">%巴特沃斯低通</span></span><br><span class="line">lpg = lpfilter(<span class="string">'gaussian'</span>, PQ(<span class="number">1</span>), PQ(<span class="number">2</span>), D0);<span class="comment">%高斯低通</span></span><br><span class="line"></span><br><span class="line">hpi = hpfilter(<span class="string">'ideal'</span>, PQ(<span class="number">1</span>), PQ(<span class="number">2</span>), D0);   <span class="comment">%理想高通</span></span><br><span class="line">hpb = hpfilter(<span class="string">'btw'</span>, PQ(<span class="number">1</span>), PQ(<span class="number">2</span>), D0, n);  <span class="comment">%巴特沃斯高通</span></span><br><span class="line">hpg = hpfilter(<span class="string">'gaussian'</span>, PQ(<span class="number">1</span>), PQ(<span class="number">2</span>), D0);<span class="comment">%高斯高通</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%步骤四五六，直接使用dftfilt函数</span></span><br><span class="line">glpi = dftfilt(f, lpi, <span class="string">'original'</span>);</span><br><span class="line">glpb = dftfilt(f, lpb, <span class="string">'original'</span>);</span><br><span class="line">glpg = dftfilt(f, lpg, <span class="string">'original'</span>);</span><br><span class="line"></span><br><span class="line">ghpi = dftfilt(f, hpi, <span class="string">'original'</span>);</span><br><span class="line">ghpb = dftfilt(f, hpb, <span class="string">'original'</span>);</span><br><span class="line">ghpg = dftfilt(f, hpg, <span class="string">'original'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">%显示滤波后的图像</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>);</span><br><span class="line">imshow(f);</span><br><span class="line">title(<span class="string">'原图'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">2</span>);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>);</span><br><span class="line">imshow(glpi);</span><br><span class="line">title(<span class="string">'理想低通滤波'</span>);</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>);</span><br><span class="line">imshow(glpb);</span><br><span class="line">title(<span class="string">'巴特沃斯低通滤波'</span>);</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line">imshow(glpg);</span><br><span class="line">title(<span class="string">'高斯低通'</span>);</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">imshow(ghpi);</span><br><span class="line">title(<span class="string">'理想高通'</span>);</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>);</span><br><span class="line">imshow(ghpb);</span><br><span class="line">title(<span class="string">'巴特沃斯高通'</span>);</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>);</span><br><span class="line">imshow(ghpg);</span><br><span class="line">title(<span class="string">'高斯高通'</span>);</span><br></pre></td></tr></table></figure>
<p>实验结果：</p>
<p>原图<img src="3.png" style="zoom:50%;"></p>
<p>滤波后<img src="4.png" style="zoom:67%;"></p>
<h3 id="实验题二"><a href="#实验题二" class="headerlink" title="实验题二"></a>实验题二</h3><p>目的：利用高频增强滤波增强图像。</p>
<p>原理：</p>
<script type="math/tex; mode=display">
H_{hfe}(u,v)=a+bH_{hp}(u,v)</script><p>a是偏移量，b是乘数，$H_{hp}(u,v)$是高通滤波器的传递函数；</p>
<p>代码：</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% hfef.m</span></span><br><span class="line"><span class="comment">%%High-Frequency Emphasis Filter</span></span><br><span class="line"></span><br><span class="line">clc;</span><br><span class="line">clear;</span><br><span class="line"></span><br><span class="line">f = imread(<span class="string">'1.png'</span>);</span><br><span class="line"></span><br><span class="line">PQ = paddedsize(<span class="built_in">size</span>(f));<span class="comment">%获得填充参数</span></span><br><span class="line">DO=<span class="number">0.05</span>*PQ(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">HBW = hpfilter(<span class="string">'btw'</span>, PQ(<span class="number">1</span>), PQ(<span class="number">2</span>), DO, <span class="number">2</span>);<span class="comment">%巴特沃斯高通滤波</span></span><br><span class="line">H = <span class="number">0.5</span> + <span class="number">2</span>*HBW;</span><br><span class="line"></span><br><span class="line">gbw = dftfilt(f, HBW, <span class="string">'fltpoint'</span>); </span><br><span class="line">gbw = gscale(gbw);<span class="comment">% 转换成UNIT8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ghf = dftfilt(f, H, <span class="string">'fltpoint'</span>);</span><br><span class="line">ghf = gscale (ghf);<span class="comment">% 转换成UNIT8</span></span><br><span class="line"></span><br><span class="line">ghe = histeq(ghf, <span class="number">256</span>); <span class="comment">%直方图均衡化</span></span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">imshow(f);</span><br><span class="line">title(<span class="string">'原图'</span>);</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">imshow(gbw);</span><br><span class="line">title(<span class="string">'巴特沃斯高通滤波后'</span>);</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">imshow(ghf);</span><br><span class="line">title(<span class="string">'高频增强后'</span>);</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>);</span><br><span class="line">imshow(ghe);</span><br><span class="line">title(<span class="string">'高频增强接着直方图均衡后'</span>);</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="5.png" style="zoom:67%;"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://dongxh.cn/2020/03/26/频域滤波实验报告/" data-id="ck8l56qhc000dtmlktots6f44" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数字图像处理/">数字图像处理</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-空间域滤波器实验报告" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/25/空间域滤波器实验报告/" class="article-date">
  <time datetime="2020-03-25T08:51:24.000Z" itemprop="datePublished">2020-03-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Digital-Image-Process/">Digital Image Process</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/25/空间域滤波器实验报告/">空间域滤波实验报告</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="空间域滤波实验报告"><a href="#空间域滤波实验报告" class="headerlink" title="空间域滤波实验报告"></a>空间域滤波实验报告</h1><h3 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容:"></a>实验内容:</h3><p> 1.编程实现一幅8比特图像的比特平面分割。</p>
<p> 2.思考课后习题3.14、3.17、3.21，并编程验证思路。</p>
<h3 id="实验过程："><a href="#实验过程：" class="headerlink" title="实验过程："></a>实验过程：</h3><h4 id="实验题一-8比特图像比特面分割"><a href="#实验题一-8比特图像比特面分割" class="headerlink" title="实验题一  8比特图像比特面分割"></a>实验题一  8比特图像比特面分割</h4><p>原理：把数字图像分解成为<strong>位平面</strong>，高阶位如前4位包含视觉上很重要的大多数数据；其它位对图像中的更多微小细节有作用。</p>
<p><img src="2.png" style="zoom: 33%;"></p>
<p>算法：</p>
<ol>
<li>读入图像，并读出图像行数r和列数c</li>
<li>创建一个r*c*8的三维矩阵</li>
<li>按照比特面从小到大，逐行逐列遍历，满足条件$2^{n-1}&lt;p_{ij}\leqslant2^n$的像素点，则将其灰度值赋给第n层比特面相应的位置，不满足的点赋值为0。</li>
</ol>
<p>代码：</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">clear;</span><br><span class="line">clc;</span><br><span class="line">f = imread(<span class="string">'aaa.tif'</span>);</span><br><span class="line"><span class="comment">%f = rgb2gray(f);</span></span><br><span class="line">[r,c] = <span class="built_in">size</span>(f);</span><br><span class="line">f1 = double(f)./<span class="number">256</span>;</span><br><span class="line">subplot(<span class="number">3</span>,<span class="number">3</span>,<span class="number">1</span>);</span><br><span class="line">imshow(f1,[]);</span><br><span class="line">title(<span class="string">'原图'</span>);</span><br><span class="line">bitImage = <span class="built_in">zeros</span>(r,c,<span class="number">8</span>);</span><br><span class="line"><span class="keyword">for</span> n = <span class="number">1</span>:<span class="number">8</span></span><br><span class="line">    <span class="keyword">for</span> ri =<span class="number">1</span>:r</span><br><span class="line">        <span class="keyword">for</span> ci = <span class="number">1</span>:c</span><br><span class="line">            <span class="comment">%temp = f(ri,ci);</span></span><br><span class="line">            <span class="keyword">if</span>(f(ri,ci)&gt;<span class="number">2</span>^(n<span class="number">-1</span>) &amp;&amp; f(ri,ci)&lt;=<span class="number">2</span>^n)</span><br><span class="line">                bitImage(ri,ci,n)=f1(ri,ci);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                bitImage(ri,ci,n)=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    subplot(<span class="number">3</span>,<span class="number">3</span>,n+<span class="number">1</span>);</span><br><span class="line">    imshow(bitImage(:,:,n),[]);</span><br><span class="line">    titlename = strcat(<span class="string">'第'</span>,num2str(n),<span class="string">'比特面'</span>);</span><br><span class="line">    title(titlename);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>实验结果：</p>
<p><img src="3.png" style="zoom:100%;"></p>
<h4 id="实验题二"><a href="#实验题二" class="headerlink" title="实验题二"></a>实验题二</h4><p><img src="1.png" style="float:left;zoom: 33%;"> <img src="left.jpg" style="zoom:25%;"> <img src="right.jpg" style="zoom:25%;"> </p>
<p>代码：</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">clc;</span><br><span class="line">clear;</span><br><span class="line">left = imread(<span class="string">'left.jpg'</span>);</span><br><span class="line">right = imread(<span class="string">'right.jpg'</span>);</span><br><span class="line">w3 = fspecial(<span class="string">'average'</span>,[<span class="number">3</span> <span class="number">3</span>]); <span class="comment">%掩模模版--3x3的均值滤波</span></span><br><span class="line">left2 = imfilter(left, w3, <span class="string">'conv'</span>, <span class="string">'circular'</span>, <span class="string">'same'</span>);</span><br><span class="line">right2 = imfilter(right, w3, <span class="string">'conv'</span>, <span class="string">'circular'</span>, <span class="string">'same'</span>);</span><br><span class="line">subplot(<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">imshow(left);</span><br><span class="line">subplot(<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">imshow(right);</span><br><span class="line">subplot(<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">imshow(left2);</span><br><span class="line">subplot(<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>);</span><br><span class="line">imshow(right2);</span><br><span class="line">subplot(<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>);</span><br><span class="line">stairs(imhist(left2, <span class="number">256</span>)/<span class="built_in">numel</span>(left2));</span><br><span class="line">subplot(<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>);</span><br><span class="line">stairs(imhist(right2, <span class="number">256</span>)/<span class="built_in">numel</span>(right2));</span><br></pre></td></tr></table></figure>
<p><img src="4.png" style="zoom:67%;"></p>
<p><img src="5.png" style="zoom:67%;"></p>
<p><img src="6.png" style="zoom:67%;"></p>
<h4 id="实验题三"><a href="#实验题三" class="headerlink" title="实验题三"></a>实验题三</h4><p><img src="7.png" style="zoom: 50%;"></p>
<p>代码：</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">clc;</span><br><span class="line">clear;</span><br><span class="line">f = imread(<span class="string">'aaa.tif'</span>);</span><br><span class="line">f3 = f;</span><br><span class="line">f5 = f;</span><br><span class="line">w3 = fspecial(<span class="string">'gaussian'</span>,[<span class="number">3</span> <span class="number">3</span>]);</span><br><span class="line">w5 = fspecial(<span class="string">'gaussian'</span>,[<span class="number">5</span> <span class="number">5</span>]);</span><br><span class="line">n = <span class="number">16</span>;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:n</span><br><span class="line">    f3 = imfilter(f3, w3, <span class="string">'conv'</span>, <span class="string">'circular'</span>, <span class="string">'same'</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:n</span><br><span class="line">    f5 = imfilter(f5, w3, <span class="string">'conv'</span>, <span class="string">'circular'</span>, <span class="string">'same'</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>);</span><br><span class="line">imshow(f);</span><br><span class="line">title(<span class="string">'原图'</span>);</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>);</span><br><span class="line">imshow(f3);</span><br><span class="line">title(<span class="string">'3x3高斯低通16次循环'</span>);</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line">imshow(f5);</span><br><span class="line">title(<span class="string">'5x5高斯低通16次循环'</span>);</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="8.png" style="zoom:50%;"></p>
<h4 id="实验题四"><a href="#实验题四" class="headerlink" title="实验题四"></a>实验题四</h4><p><img src="9.png" style="zoom:54%;"></p>
<p>分析过程：</p>
<p>我们所分析的现象显然与条形图像的水平间隔有关。因此我们可以考虑垂直于条形图的一条扫描线来简化问题。</p>
<p><img src="10.png" style="zoom:50%;"></p>
<p>如图所示，我们假设每条的宽度为5，间隔为20。当掩模的宽度恰好为20+5=25时，不论掩模在水平方向上如何移动，水平范围内，一定包含了相等数量的‘黑像素点’，由于时均值模型，所以不论掩模空间位置在何处，掩模中心的值都是相等的，为5/25=0.2。所以条形区内是模糊的，无法辨认。当掩模的宽度不是25的整数倍时，滤波后，仍然会显出条形特征。</p>
<p>验证过程：</p>
<ol>
<li>创建一个有特定值的条形图片（每条宽度10，间隔20）</li>
<li>分别用15x15，30x30，50x50的均值滤波器来处理图像</li>
<li>观察结果</li>
</ol>
<p>代码：</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">clc;</span><br><span class="line">clear;</span><br><span class="line">A = [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span>;<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span>;<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span>;<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span>;<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span>;<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span>;<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span>;<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span>;<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span>;<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span>;]</span><br><span class="line">A = <span class="built_in">repmat</span>(A,<span class="number">100</span>,<span class="number">40</span>);</span><br><span class="line">w15 = fspecial(<span class="string">'average'</span>,[<span class="number">15</span> <span class="number">15</span>]);</span><br><span class="line">w30 = fspecial(<span class="string">'average'</span>,[<span class="number">30</span> <span class="number">30</span>]);</span><br><span class="line">w50 = fspecial(<span class="string">'average'</span>,[<span class="number">50</span> <span class="number">50</span>]);</span><br><span class="line">A15 = imfilter(A, w15, <span class="string">'conv'</span>, <span class="string">'circular'</span>, <span class="string">'same'</span>);</span><br><span class="line">A30 = imfilter(A, w30, <span class="string">'conv'</span>, <span class="string">'circular'</span>, <span class="string">'same'</span>);</span><br><span class="line">A50 = imfilter(A, w50, <span class="string">'conv'</span>, <span class="string">'circular'</span>, <span class="string">'same'</span>);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">imshow(A);</span><br><span class="line">title(<span class="string">'原图'</span>);</span><br><span class="line"><span class="comment">%</span></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">imshow(A15);</span><br><span class="line">title(<span class="string">'15x15'</span>);</span><br><span class="line"><span class="comment">%</span></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">imshow(A30);</span><br><span class="line">title(<span class="string">'30x30'</span>);</span><br><span class="line"><span class="comment">%</span></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>);</span><br><span class="line">imshow(A50);</span><br><span class="line">title(<span class="string">'50x50'</span>);</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="11.png" style="zoom:50%;"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://dongxh.cn/2020/03/25/空间域滤波器实验报告/" data-id="ck8l56qh6000atmlk0hm3ne19" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数字图像处理/">数字图像处理</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-图像复原" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/24/图像复原/" class="article-date">
  <time datetime="2020-03-24T08:09:12.000Z" itemprop="datePublished">2020-03-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Digital-Image-Process/">Digital Image Process</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/24/图像复原/">图像复原</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="图像复原"><a href="#图像复原" class="headerlink" title="图像复原"></a>图像复原</h1><h2 id="理论知识"><a href="#理论知识" class="headerlink" title="理论知识"></a>理论知识</h2><p><img src="1.png" style="zoom:90%;"></p>
<h3 id="图像退化-复原过程"><a href="#图像退化-复原过程" class="headerlink" title="图像退化/复原过程"></a>图像退化/复原过程</h3><p>什么是退化：图像在获取(成像传感器)和传输(信道干扰)过程中, 由于成像系统、记录设备、传输介质和处理方法得不完 善，导致图像质量下降，称为图像退化.</p>
<p>退化的原因：</p>
<ol>
<li>成像系统的散焦</li>
<li>成像设备与物体的相对运动</li>
<li>成像器材的固有缺陷</li>
<li>外部干扰</li>
</ol>
<p>图像退化模型：</p>
<script type="math/tex; mode=display">
G(u,v)=H(u,v)F(u,v)+N(u,v)</script><p><img src="2.png" style="zoom:50%;"></p>
<p><strong>图像复原</strong>：</p>
<p>图像复原是试图利用退化过程的先验知识（退化模型化）使已退化的图像恢复本来面目的过程。</p>
<p>图像复原的目的是消除或减轻在图像获取以及传输过程中造成的图像品质下降，补偿退化过程造成的失真</p>
<p>图像复原可以看成图像退化的逆过程。</p>
<p>在图像退化确知的情况下，图像退化的逆过程是有可能进行的。但实际情况经常是退化过程并不知晓，这种复原称为<strong>盲目复原</strong>。</p>
<p>由于图像模糊的同时，噪声和干扰也会同时存在，这也为复原带来了困难和不确定性</p>
<p>图像增强 VS 图像复原</p>
<p><img src="3.png" style="zoom: 33%;"></p>
<p>图像复原技术的分类：</p>
<ul>
<li>在给定退化模型下，分为<strong>无约束</strong>和<strong>有约束</strong></li>
<li>根据是否需要外界干预，分为<strong>自动</strong>和<strong>交互</strong></li>
<li>根据处理所在的域，分为<strong>频域</strong>和<strong>空间域</strong></li>
</ul>
<h3 id="噪声模型"><a href="#噪声模型" class="headerlink" title="噪声模型"></a>噪声模型</h3><p>噪声的来源：主要来源于图像的获取（数字化过程）和传输过程：</p>
<ul>
<li>数字图像的噪声主要来源于图像的获取和传输过程；</li>
<li>图像获取的数字化过程，如图像传感器的质量和环境条件；</li>
<li>图像传输过程中传输信道的噪声干扰，如通过无线网络传输的图像会受到光或其它大气因素的干扰；</li>
</ul>
<p>噪声的空间和频率特性：</p>
<ul>
<li>频率特性指噪声在傅立叶域的频率内容。</li>
<li>空间特性：除周期噪声以外，假设噪声独立于空间坐标，并且它与图像本身无关联。</li>
<li>空间噪声利用退化模型中噪声分量的灰度值统计特性来表示。</li>
<li>可以被认为是由概率密度函数表示的随机变量。</li>
</ul>
<p>图像处理中常见噪声概率分布函数：高斯噪声，瑞丽噪声，伽马（爱尔兰）噪声，指数分布噪声，均匀分布噪声，脉冲（椒盐）噪声；</p>
<p><img src="4.png" style="zoom:50%;"></p>
<p>在实际应用中，往往假设噪声是白噪声，即它的频谱密度为常数，且与图像不相关。</p>
<p>不同的复原技术需要不同的有关噪声的先验信息，如维纳滤波器需要知道噪声的谱密度，而约束去卷积法只需要知道噪声的协方差.</p>
<p><strong>高斯噪声</strong></p>
<script type="math/tex; mode=display">
p(z)=\frac{1}{\sqrt{2\pi\sigma}}e^{-(z-\mu)^2/2\sigma^2}</script><p>其中$z$表示灰度值，$\mu$表示$z$的平均值或期望，$\sigma$表示$z$的标准差，标准差的平方$\sigma^2$称为$z$的方差。</p>
<p><strong>瑞丽噪声</strong></p>
<script type="math/tex; mode=display">
p(z)=\left\{\begin{matrix}
\frac{2}{b}(z-a)e^{-(z-a)^2/b} & z\geqslant a\\ 
 0 & z<a
\end{matrix}\right.</script><p>概率密度的均值为$\mu = a+\sqrt{\pi b/4}$，方差为$\sigma^2 = \frac{b(4-\pi)}{4}$   。</p>
<p><strong>伽马（爱尔兰）噪声</strong></p>
<script type="math/tex; mode=display">
p(z)=\left\{\begin{matrix}
\frac{a^b z^{b-1}}{(b-1)!}e^{-az} &z\geqslant 0 \\ 
0 & z< 0
\end{matrix}\right.</script><p>其中，$a&gt;0$，$b$为正整数。概率密度的均值$\mu = \frac{b}{a}$，方差是$\sigma^2=\frac{b}{a^2}$  。</p>
<p><strong>指数分布噪声</strong></p>
<script type="math/tex; mode=display">
p(z)=\left\{\begin{matrix}
ae^{-ax} &z\geqslant 0 \\ 
0 & z< 0
\end{matrix}\right.</script><p>其中，$a&gt;0$ 。概率密度的均值$\mu = \frac{1}{a}$，方差是$\sigma^2=\frac{1}{a^2}$  。</p>
<p><strong>均匀分布噪声</strong></p>
<script type="math/tex; mode=display">
p(z)=\left\{\begin{matrix}
\frac{1}{b-1}&a\leqslant z\leqslant  b \\ 
0 & orther
\end{matrix}\right.</script><p>概率密度的均值$\mu = \frac{a+b}{2}$，方差是$\sigma^2=\frac{(b-a)^2}{12}$  。</p>
<p><strong>椒盐噪声</strong></p>
<script type="math/tex; mode=display">
p(z)=\left\{\begin{matrix}
P_a &z=a \\ 
P_b &a=b \\ 
 0 & orther
\end{matrix}\right.</script><p>若是$b&gt;a$,则灰度值$b$将显示为一个亮点，$a$的值将显示为一个暗点</p>
<p>若$P_a$或$P_b$为零，则脉冲噪声成为单极脉冲。</p>
<p>若$P_a$或$P_b$均不可能为零,尤其是近似相等时,脉冲噪声值类似于随机分布在图像上的胡椒和盐粉细粒.</p>
<p><strong>各种噪声效果图</strong></p>
<p><img src="5.png" style="zoom: 40%;"></p>
<p><img src="6.png" style="zoom:40%;"></p>
<p><strong>几种噪声模型的运用</strong></p>
<ul>
<li>高斯噪声用于描述源于电子电路噪声和由低照明度或高温带来的传感器噪声</li>
<li>瑞利噪声用于在图像范围内特征化噪声现象</li>
<li>伽马分布和指数分布用于描述激光成像噪声</li>
<li>均匀密度分布作为模拟随机数产生器的基础</li>
<li>脉冲噪声用于描述成像中的短暂停留(如错误的开关操作)</li>
</ul>
<p><strong>周期噪声</strong></p>
<p>本文章讨论的唯一空间依赖型噪声，周期噪声可以通过频率域滤波显著减少。</p>
<p><img src="7.png" style="zoom:30%;"></p>
<p>周期噪声的参数估计是通过检测图像的傅里叶变换来进行估计的。</p>
<p><strong>噪声的参数估计</strong></p>
<p>统计一小块图像的灰度直方图，判断噪声的分布函数类型；</p>
<p>计算样本的噪声的均值，</p>
<script type="math/tex; mode=display">
\mu =\sum_{z_i\in S}z_i p(z_i)</script><p>方差，</p>
<script type="math/tex; mode=display">
\sigma ^2 = \sum_{z_i\in S}(z_i - \mu)^2p(z_i)</script><p>其中$z_i$值是像素的灰度值，$p(z_i)$表示相应的归一化直方图。</p>
<h3 id="只存在噪声的空间滤波复原"><a href="#只存在噪声的空间滤波复原" class="headerlink" title="只存在噪声的空间滤波复原"></a>只存在噪声的空间滤波复原</h3><p>当且仅当加性噪声存在时，可以选择空间滤波方法。</p>
<p>由于<strong>均值滤波器</strong>和<strong>统计排序滤波器</strong>的原理公式已在以前的文章总结，这里不多赘述，只描述一下有特定良好用途的；</p>
<p><strong>均值滤波器</strong></p>
<p>​        谐波均值滤波器，对“盐”的噪声效果好，但不适合“胡椒”；</p>
<p>​        逆谐波均值滤波器，Q为滤波器的阶数，当Q值为正数时 滤波器用于消除”胡椒”噪声；当Q值为负数时，滤波器用于消除”盐”噪声；当Q=0时，逆谐波均值滤波器退化为算术均值滤波器；当Q=-1时，逆谐波均值滤波器退化为谐波均值滤波器。</p>
<ul>
<li><p>​    算术均值和几何均值都能衰减噪声。 但比较而言,几何均值滤波器的结果图像相对较清晰.</p>
</li>
<li><p>​    算术和几何适合处理高斯或均匀等随机噪声。逆谐波更适于处理脉冲噪声</p>
</li>
<li><p>​    使用谐波滤波器需要知道噪声是暗噪声还是热噪声，已选择合适的Q值的正负号类型。</p>
</li>
</ul>
<p><strong>统计排序滤波器</strong></p>
<p>​        中值滤波器：在相同尺寸下，比起均值滤波器引起的模糊少；对单极或双极脉冲噪声非常有效。</p>
<p>​        最大值滤波器：用于发现图像中的最亮点；可以有效过滤“胡椒”噪声（因为“胡椒”噪声是非常低的值）。</p>
<p>​        最小值滤波器：用于发现图像中的最暗点；可以有效过滤“盐”噪声（因为“盐”噪声是非常高的值）。</p>
<p>​        中点滤波器：结合了顺序统计和求平均 ；对于高斯和均匀随机分布这类噪声有最好的效果。</p>
<p>​        <img src="8.png" style="zoom:40%;"></p>
<ul>
<li>可多次应用中值滤波逐渐消除噪声，但多次应用中值滤波器,，会使图像模糊</li>
<li>最大值滤波器可以去除”胡椒”噪声，但会从黑色物体边缘移走一些黑色像素。(亮物体 变大，暗物体变小)</li>
<li>最小值滤波器可以去除”盐” 噪声，但会从亮色物体边缘移走一些白色像素。(亮物体变小， 暗物体变大)</li>
<li>由于脉冲噪声的存在，算术均值滤波器和几何均值滤波器没有起到良好作用。</li>
<li>中值滤波器和阿尔法滤波器效果更好,阿尔法最好.</li>
</ul>
<p><strong>自适应滤波器</strong></p>
<p>之前介绍的滤波器都没有考虑过图像中的一点对于其他点的特征变化。</p>
<p>滤波器的特征变化是以「$m\times n$的矩形窗口$S_{xy}$定义的滤波器区域内」图像的统计特性为基础的。</p>
<p>自适应滤波器的性能要更优，复杂度更高。（这里的背景是针对的图像还是只有噪声干扰的图像）</p>
<p>这里介绍两种自适应滤波器：</p>
<ol>
<li>自适应局部降噪滤波器</li>
<li>自适应中值滤波器</li>
</ol>
<p><strong>自适应局部降噪滤波器</strong></p>
<p>​        随机变量最简单的统计度量是均值和方差。在图像领域，对于滤波器来说，均值给出了在其计算均值的区域中平均灰度的度量，而<u>方差则给出了该区域的对比度的度量</u>。</p>
<p>​        滤波器作用于局部区域$S_{xy}$。滤波器在该区域中心$(x,y)$任意一点上的响应基于一下4个量：</p>
<ul>
<li>$g(x,y)$，带噪图像在该点$(x,y)$上的是</li>
<li>$\sigma_{\eta}^2$，污染$f(x,y)$以形成$g(x,y)$的噪声的方差</li>
<li>$m_L$，$S_{xy}$中像素的局部均值</li>
<li>$\sigma_{L}^2$，$S_{xy}$中像素的局部方差</li>
</ul>
<p>​        我们希望滤波器有性能如下：</p>
<ol>
<li>如果$\sigma_{\eta}^2=0$，则滤波器简单的返回$g(x,y)$就行了，因为噪声的方差为零，意味着是零噪声情况下，$f(x,y)=g(x,y)$。</li>
<li>如果局部方差与$\sigma_{\eta}^2$是高相关的, 那么滤波器要返回一个$g(x, y)$的近似值。典型的，高局部方差与边缘有关，并且应该保护这些边缘</li>
<li>如果两个方差相等,希望滤波器返回区域$S_{xy}$上像素的算数平均。这种情况发生在局部区域与整个图像有相同特性的条件下，并且并且局部噪声将通过简单地求平均来降低。</li>
</ol>
<p>基于这些要求得到的自适应滤波器表达式可以写成：</p>
<script type="math/tex; mode=display">
\hat{f}(x,y)=g(x,y)-\frac{\sigma_{\mu}^2}{\sigma_L^2}[g(x,y)-m_L]</script><p>​        在四个量中，唯一需要估计的量就是全部噪声的方差$\sigma_{\mu}^2$，其他参数可以有模版$S_{xy}$的包围的像素数据得出。一般假设$\sigma_{\eta}^2\leqslant\sigma_{L}^2$。模型中的噪声是加性的和位置独立的。</p>
<p>​        因为在现实中，很可能无法满足$\sigma_{\eta}^2\leqslant\sigma_{L}^2$这个一般假设，所以应设置一个条件，当$\sigma_{\eta}^2&lt;\sigma_{L}^2$时，设置$\frac{\sigma_{\mu}^2}{\sigma_L^2}$为1。</p>
<p><strong>自适应中值滤波器</strong></p>
<p>自适应中值滤波器与传统中值滤波器的区别：</p>
<p>​        传统中值滤波器只能处理空间密度不大的冲激噪声（$P_a,P_b&lt;0.2$），而自适应中值滤波器可以处理具有更大概率的冲激噪声；可以在平滑非冲激噪声时保存细节，而传统中值滤波器无法做到。</p>
<p>自适应中值滤波的主要目的：</p>
<ul>
<li>除去“椒盐”噪声(冲激噪声)</li>
<li>平滑其它非冲激噪声</li>
<li>减少物体边界细化或粗化等失真</li>
</ul>
<p>自适应中值滤波器也工作于矩形窗口$S_{xy}$中，而且，自适应中值滤波器有一个特性，它会根据某些条件改变$S_{xy}$的尺寸。</p>
<p>规定如下符号：</p>
<ul>
<li>$z_{min}=S_{xy}$中的最小灰度值</li>
<li>$z_{max}=S_{xy}$中的最大灰度值</li>
<li>$z_{med}=S_{xy}$中的灰度值中值</li>
<li>$z_{xy}=$坐标$(x,y)$处的灰度值</li>
<li>$S_{max}=S_{xy}$允许的最大尺寸</li>
</ul>
<p>自适应中值滤波器算法工作在两个层次, 定义为A层和B层 :</p>
<p>A层：<em>(决定中值滤波的输出$z_{med}$是否是一个脉冲)</em></p>
<ul>
<li>$A_1=z_{med}-z_{min}$</li>
<li>$A_2=z_{med}-z_{max}$</li>
<li>如果$A_1&gt;0$且$A_2&lt;0$,则转到$B$层 <em>(不是一个脉冲)</em></li>
<li>否则增大窗口尺寸，<em>（找到一个脉冲，就增大窗口尺寸，直到找到非脉冲）</em></li>
<li>如果窗口尺寸$&lt;S_{max}$ ,重复A层</li>
<li>否则输出$z_{xy}$</li>
</ul>
<p>B层：<em>（检测中心点$z_{xy}$本身是不是一个脉冲</em>）</p>
<ul>
<li>$B_1=z_{xy}-z_{min}$</li>
<li>$B_2=z_{xy}-z_{max}$</li>
<li>若$B_1&gt;0$且$B_2&lt;0$,则输出$z_{xy}$ <em>（不是脉冲，直接输出）</em></li>
<li>否则输出$z_{med}$  （此时$z_{xy}=z_{min}$或者$z_{xy}=z_{max}$）</li>
</ul>
<h3 id="频域滤波器消减周期噪声"><a href="#频域滤波器消减周期噪声" class="headerlink" title="频域滤波器消减周期噪声"></a>频域滤波器消减周期噪声</h3><p>带阻滤波器，带通滤波器和陷波滤波器以前文章有详细介绍；</p>
<p>问题：为什么水平线的周期噪声要用如c图的陷波带通滤波器？</p>
<p><img src="9.png" style="zoom: 33%;"></p>
<p><strong>最佳陷波滤波器</strong></p>
<p>当存在几种干扰时,采用一般滤波器可能在滤波过程中可能消除太多图像信息。干扰成分通常不是单频脉冲。相反，他们通常有携带干扰模式信息的宽边缘。最佳的意思是，在一定意义上，它最小化的复原的估计值$\hat{f}(x,y)$的局部方差。</p>
<p>实现的步骤由两个部分组成：</p>
<ol>
<li>屏蔽干扰的主要成分；</li>
<li>从被干扰的图像中减去一个可变的模式加权部分。</li>
</ol>
<p>详细原理可见教材P214～P215</p>
<h3 id="线性，位置不变的的退化模型"><a href="#线性，位置不变的的退化模型" class="headerlink" title="线性，位置不变的的退化模型"></a>线性，位置不变的的退化模型</h3><p>退化模型：</p>
<script type="math/tex; mode=display">
g(x,y)=H[f(x,y)]+\eta(x,y)</script><p>$H$是一个线性系统：</p>
<script type="math/tex; mode=display">
H[af_1(x,y)+bf_2(x,y)]=aH[f_1(x,y)+bH[f_2(x,y)]</script><p>$H$是一个位置不变系统（空间不变系统）：</p>
<script type="math/tex; mode=display">
H[f(x-\alpha,y-\beta)]=g(x-\alpha,y-\beta)</script><p>许多退化类型可以近似表示为线性的位置不变过程；</p>
<p>由于退化模型为卷积的结果， 因此术语“图像去卷积”常用于表示线性图像复原；</p>
<p>由于图像复原需要滤波器，而用于复原处理的滤波器称为“去卷积滤波器”。</p>
<h3 id="估计退化函数"><a href="#估计退化函数" class="headerlink" title="估计退化函数"></a>估计退化函数</h3><p>​        退化函数通常未知，因此在复原之前需要估计退化函数。使用以某种方式估计的退化函数来复原一幅图像的过程，有时候称为盲去卷积。</p>
<p>估计方法：1.观察法；2.试验法；3.数学建模法；</p>
<p><strong>观察法</strong></p>
<p>若我们没有任何关于退化函数的信息，我们只能从图像本身来收集信息。</p>
<p>在图像中选取一块有很强信号内容的（高对比度的）矩形区域$g_s(x,y)$，然后用处理这个子图像使其尽可能的不模糊，得到$\hat{f}(x,y)$。则可以得到：</p>
<script type="math/tex; mode=display">
H_s(u,v)=\frac{G_s(u,v)}{\hat{F}(u,v)}</script><p>根据这个函数特性，我们可以基于位置不变的假设还原完整的退化函数$H(u,v)$。</p>
<p><strong>试验法</strong></p>
<p>用与获取退化图像的设备相同或相似的装置来做矫正。也就是得到冲激响应即可</p>
<p><strong>数学建模法</strong></p>
<p>利用经验模型或者原理模型来解释一个退化函数。</p>
<p>经典案例：<strong>运动图像模糊</strong></p>
<p>上述事件可以抽象成，摄像机与物体的相对线性运动：摄像机与被摄物体在快门打开期间T内的相对运动，会引起物体在图像中的平滑，即图像数据为快门打开期间内瞬时曝光值的积分。它产生的H函数如下：</p>
<script type="math/tex; mode=display">
H(u,v)=\frac{T}{\pi (ua+vb)}sin[\pi (ua+vb)]e^{-j\pi(ua+vb)}</script><p>$a,b$反映了运动在x和y轴的速度，即假设图像只在$x$和$y$方向上做匀速直线运动，当$t=T$时，图像位移的总距离为$a$和$b$。</p>
<h3 id="逆滤波"><a href="#逆滤波" class="headerlink" title="逆滤波"></a>逆滤波</h3><p>原始图像的傅里叶变换估计为$\hat{F}(u,v)$。</p>
<p>不考虑噪声的情况下的逆滤波：</p>
<script type="math/tex; mode=display">
\hat{F}(u,v)=\frac{G(u,v)}{H(u,v)}</script><p>考虑噪声情况下的逆滤波：</p>
<script type="math/tex; mode=display">
\hat{F}(u,v)=\frac{G(u,v)}{H(u,v)}+\frac{N(u,v)}{H(u,v)}=F(u,v)+\frac{N(u,v)}{H(u,v)}</script><p>在实际情况中，噪声$N(u,v)$是存在的，如果$H(u,v)$非常小或者接近0时，会导致噪声占据估计值的统治地位，解决办法之一：加入低通滤波器，即把$G(u,v)/H(u,v)$的结果进行低通滤波，去除部分噪声的效果。</p>
<p><strong>直接逆滤波</strong></p>
<p><img src="10.png" style="zoom:50%;"></p>
<p><strong>最小均方差误差滤波（维纳滤波）</strong></p>
<p>直接逆滤波没有考虑噪声。维纳滤波综合考虑退化函数和噪声统计特征。</p>
<p>认为图像和噪声是随机函数，目标是找未污染图像$f$的估计值$\hat{f}$,使它们之间的均方误差$e^2=E[(f-\hat{f})^2]$最小.</p>
<p><img src="11.png" style="zoom:50%;"></p>
<p><img src="12.png" style="zoom:50%;"></p>
<h3 id="几何校正"><a href="#几何校正" class="headerlink" title="几何校正"></a>几何校正</h3><p>图像获取和显示过程中，由于成像系统本身的非线性，图像获取视角的变化及拍摄对象表面弯曲等原因，产生图像几何形状的失真。</p>
<p><img src="13.png" style="zoom: 33%;"></p>
<p><img src="14.png" style="zoom:45%;"></p>
<h2 id="Matlab实现"><a href="#Matlab实现" class="headerlink" title="Matlab实现"></a>Matlab实现</h2><p><strong>使用imnoise添加噪声</strong></p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g = imnoise ( f , <span class="built_in">type</span> , parameters );</span><br></pre></td></tr></table></figure>
<p>在函数imnoise()给图像添加噪声之前，要将图像转换成范围为[0,1]的double类图像。例如我们要把均值为64，方差为400的高斯噪声添加到一幅unit8类图像上的时候，我们可以将均值标化为64/255，将方差标化为400/(225)^2^，以便作为imnoise函数的输入。</p>
<p><img src="15.png" style="zoom:50%;"></p>
<p>空间噪声值是随机数，以概率密度(PDF)或者相应的累积分布函数(CDF)表征。许多随机数生成器是以在区间[0,1]内具有均匀CDF的随机数生成问题，而有些例子中选择的基本随机数生成器是零均值、单位方差的高斯随机数生成器。虽然可以用imnoise来生成两种类型的噪声，但更有意义的是用rand()函数生成均匀随机数，和randn生成正态（高斯）随机数。</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A = <span class="built_in">rand</span>(M, N);<span class="comment">%M*N大小的数组，均匀分布</span></span><br><span class="line">A = <span class="built_in">rand</span>(M);<span class="comment">%矩阵</span></span><br><span class="line">A = <span class="built_in">rand</span>();<span class="comment">%单一随机数值</span></span><br><span class="line"></span><br><span class="line">A = <span class="built_in">randn</span>(M, N);<span class="comment">%同理，均值为零，单位方差</span></span><br></pre></td></tr></table></figure>
<p><img src="16.png" style="zoom:99%;"></p>
<p>看最后一列生成器。</p>
<p><strong>一个有用的函数find()</strong></p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%%%三种形式%%%</span></span><br><span class="line"><span class="comment">%返回给I所有满足statment条件的A中元素的索引，以列向量形式来返回</span></span><br><span class="line">I = <span class="built_in">find</span>( statment about A);</span><br><span class="line"><span class="comment">%例子</span></span><br><span class="line">I = <span class="built_in">find</span>(A &lt; <span class="number">5</span>);<span class="comment">%找出A中所有小于5的元素的索引</span></span><br><span class="line">A(I) = <span class="number">0</span>;       <span class="comment">%给刚刚找出的所有元素赋值为0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%返回行和列的索引</span></span><br><span class="line">[r, c] = <span class="built_in">find</span>( statment about A);</span><br><span class="line"></span><br><span class="line"><span class="comment">%v为满足条件的值</span></span><br><span class="line">[r, c, v] = <span class="built_in">find</span>( statment about A);</span><br><span class="line"></span><br><span class="line"><span class="comment">%以上三个表达式，若是没有statment，只有一个A，则表示指向非零元素</span></span><br></pre></td></tr></table></figure>
<p><strong>函数imnoise2()</strong></p>
<p>直接产生一个大小为M*N的噪声数组R ，并不以任何方式缩放。</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">R</span> = <span class="title">imnoise2</span><span class="params">(type, varargin)</span></span></span><br><span class="line"><span class="comment">%IMNOISE2 Generates an array of random numbers with specified PDF.</span></span><br><span class="line"><span class="comment">%   R = IMNOISE2(TYPE, M, N, A, B) generates an array, R, of size</span></span><br><span class="line"><span class="comment">%   M-by-N, whose elements are random numbers of the specified TYPE</span></span><br><span class="line"><span class="comment">%   with parameters A and B. If only TYPE is included in the</span></span><br><span class="line"><span class="comment">%   input argument list, a single random number of the specified</span></span><br><span class="line"><span class="comment">%   TYPE and default parameters shown below is generated. If only</span></span><br><span class="line"><span class="comment">%   TYPE, M, and N are provided, the default parameters shown below</span></span><br><span class="line"><span class="comment">%   are used.  If M = N = 1, IMNOISE2 generates a single random</span></span><br><span class="line"><span class="comment">%   number of the specified TYPE and parameters A and B.</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">%   Valid values for TYPE and parameters A and B are:</span></span><br><span class="line"><span class="comment">% </span></span><br><span class="line"><span class="comment">%   'uniform'       Uniform random numbers in the interval (A, B).</span></span><br><span class="line"><span class="comment">%                   The default values are (0, 1).  </span></span><br><span class="line"><span class="comment">%   'gaussian'      Gaussian random numbers with mean A and standard</span></span><br><span class="line"><span class="comment">%                   deviation B. The default values are A = 0, </span></span><br><span class="line"><span class="comment">%                   B = 1.</span></span><br><span class="line"><span class="comment">%   'salt &amp; pepper' Salt and pepper numbers of amplitude 0 with</span></span><br><span class="line"><span class="comment">%                   probability Pa = A, and amplitude 1 with</span></span><br><span class="line"><span class="comment">%                   probability Pb = B. The default values are Pa =</span></span><br><span class="line"><span class="comment">%                   Pb = A = B = 0.05.  Note that the noise has</span></span><br><span class="line"><span class="comment">%                   values 0 (with probability Pa = A) and 1 (with</span></span><br><span class="line"><span class="comment">%                   probability Pb = B), so scaling is necessary if</span></span><br><span class="line"><span class="comment">%                   values other than 0 and 1 are required. The</span></span><br><span class="line"><span class="comment">%                   noise matrix R is assigned three values. If </span></span><br><span class="line"><span class="comment">%                   R(x, y) = 0, the noise at (x, y) is pepper</span></span><br><span class="line"><span class="comment">%                   (black). If R(x, y) = 1, the noise at (x, y) is</span></span><br><span class="line"><span class="comment">%                   salt (white). If R(x, y) = 0.5, there is no</span></span><br><span class="line"><span class="comment">%                   noise assigned to coordinates (x, y). </span></span><br><span class="line"><span class="comment">%   'lognormal'     Lognormal numbers with offset A and shape</span></span><br><span class="line"><span class="comment">%                   parameter B. The defaults are A = 1 and B =</span></span><br><span class="line"><span class="comment">%                   0.25.</span></span><br><span class="line"><span class="comment">%   'rayleigh'      Rayleigh noise with parameters A and B. The</span></span><br><span class="line"><span class="comment">%                   default values are A = 0 and B = 1. </span></span><br><span class="line"><span class="comment">%   'exponential'   Exponential random numbers with parameter A.  </span></span><br><span class="line"><span class="comment">%                   The default is A = 1.</span></span><br><span class="line"><span class="comment">%   'erlang'        Erlang (gamma) random numbers with parameters A</span></span><br><span class="line"><span class="comment">%                   and B. B must be a positive integer. The</span></span><br><span class="line"><span class="comment">%                   defaults are A = 2 and B = 5. Erlang random</span></span><br><span class="line"><span class="comment">%                   numbers are approximated as the sum of B</span></span><br><span class="line"><span class="comment">%                   exponential random numbers.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%   Copyright 2002-2009 R. C. Gonzalez, R. E. Woods, and S. L. Eddins</span></span><br><span class="line"><span class="comment">%   From the book Digital Image Processing Using MATLAB, 2nd ed.,</span></span><br><span class="line"><span class="comment">%   Gatesmark Publishing, 2009.</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">%   Book web site: http://www.imageprocessingplace.com</span></span><br><span class="line"><span class="comment">%   Publisher web site: http://www.gatesmark.com/DIPUM2e.htm</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% Set defaults.</span></span><br><span class="line">[M, N, a, b] = setDefaults(<span class="built_in">type</span>, varargin&#123;:&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">% Begin processing. Use lower(type) to protect against input being</span></span><br><span class="line"><span class="comment">% capitalized. </span></span><br><span class="line"><span class="keyword">switch</span> lower(<span class="built_in">type</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="string">'uniform'</span></span><br><span class="line">   R = a + (b - a)*<span class="built_in">rand</span>(M, N);</span><br><span class="line">   </span><br><span class="line"><span class="keyword">case</span> <span class="string">'gaussian'</span></span><br><span class="line">   R = a + b*<span class="built_in">randn</span>(M, N);</span><br><span class="line">   </span><br><span class="line"><span class="keyword">case</span> <span class="string">'salt &amp; pepper'</span></span><br><span class="line">   R = saltpepper(M, N, a, b);</span><br><span class="line">   </span><br><span class="line"><span class="keyword">case</span> <span class="string">'lognormal'</span></span><br><span class="line">   R = <span class="built_in">exp</span>(b*<span class="built_in">randn</span>(M, N) + a);</span><br><span class="line">   </span><br><span class="line"><span class="keyword">case</span> <span class="string">'rayleigh'</span></span><br><span class="line">   R = a + (-b*<span class="built_in">log</span>(<span class="number">1</span> - <span class="built_in">rand</span>(M, N))).^<span class="number">0.5</span>;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">case</span> <span class="string">'exponential'</span></span><br><span class="line">   R = exponential(M, N, a);</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">'erlang'</span></span><br><span class="line">   R = erlang(M, N, a, b);</span><br><span class="line"></span><br><span class="line"><span class="keyword">otherwise</span></span><br><span class="line">   error(<span class="string">'Unknown distribution type.'</span>)</span><br><span class="line">   </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%-------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">R</span> = <span class="title">saltpepper</span><span class="params">(M, N, a, b)</span></span></span><br><span class="line"><span class="comment">% Check to make sure that Pa + Pb is not &gt; 1.</span></span><br><span class="line"><span class="keyword">if</span> (a + b) &gt; <span class="number">1</span></span><br><span class="line">   error(<span class="string">'The sum Pa + Pb must not exceed 1.'</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">R(<span class="number">1</span>:M, <span class="number">1</span>:N) = <span class="number">0.5</span>;</span><br><span class="line"><span class="comment">% Generate an M-by-N array of uniformly-distributed random numbers</span></span><br><span class="line"><span class="comment">% in the range (0, 1). Then, Pa*(M*N) of them will have values &lt;= a.</span></span><br><span class="line"><span class="comment">% The coordinates of these points we call 0 (pepper noise).</span></span><br><span class="line"><span class="comment">% Similarly, Pb*(M*N) points will have values in the range &gt; a &amp; &lt;=</span></span><br><span class="line"><span class="comment">% (a + b). These we call 1 (salt noise).</span></span><br><span class="line">X = <span class="built_in">rand</span>(M, N);</span><br><span class="line">R(X &lt;= a) = <span class="number">0</span>;</span><br><span class="line">u = a + b;</span><br><span class="line">R(X &gt; a &amp; X &lt;= u) = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">%-------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">R</span> = <span class="title">exponential</span><span class="params">(M, N, a)</span></span></span><br><span class="line"><span class="keyword">if</span> a &lt;= <span class="number">0</span></span><br><span class="line">   error(<span class="string">'Parameter a must be positive for exponential type.'</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">k = <span class="number">-1</span>/a;</span><br><span class="line">R = k*<span class="built_in">log</span>(<span class="number">1</span> - <span class="built_in">rand</span>(M, N));</span><br><span class="line"></span><br><span class="line"><span class="comment">%-------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">R</span> = <span class="title">erlang</span><span class="params">(M, N, a, b)</span></span></span><br><span class="line"><span class="keyword">if</span> (b ~= <span class="built_in">round</span>(b) || b &lt;= <span class="number">0</span>)</span><br><span class="line">   error(<span class="string">'Param b must be a positive integer for Erlang.'</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">k = <span class="number">-1</span>/a;</span><br><span class="line">R = <span class="built_in">zeros</span>(M, N);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:b</span><br><span class="line">   R = R + k*<span class="built_in">log</span>(<span class="number">1</span> - <span class="built_in">rand</span>(M, N));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%-------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">varargout</span> = <span class="title">setDefaults</span><span class="params">(type, varargin)</span></span></span><br><span class="line"></span><br><span class="line">varargout = varargin;</span><br><span class="line">P = <span class="built_in">numel</span>(varargin);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> P &lt; <span class="number">4</span></span><br><span class="line">   <span class="comment">% Set default b.</span></span><br><span class="line">   varargout&#123;<span class="number">4</span>&#125; = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> P &lt; <span class="number">3</span></span><br><span class="line">   <span class="comment">% Set default a.</span></span><br><span class="line">   varargout&#123;<span class="number">3</span>&#125; = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> P &lt; <span class="number">2</span></span><br><span class="line">   <span class="comment">% Set default N.</span></span><br><span class="line">   varargout&#123;<span class="number">2</span>&#125; = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> P &lt; <span class="number">1</span></span><br><span class="line">   <span class="comment">% Set default M.</span></span><br><span class="line">   varargout&#123;<span class="number">1</span>&#125; = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (P &lt;= <span class="number">2</span>)</span><br><span class="line">   <span class="keyword">switch</span> <span class="built_in">type</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">'salt &amp; pepper'</span></span><br><span class="line">         <span class="comment">% a = b = 0.05.</span></span><br><span class="line">         varargout&#123;<span class="number">3</span>&#125; = <span class="number">0.05</span>;</span><br><span class="line">         varargout&#123;<span class="number">4</span>&#125; = <span class="number">0.05</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">'lognormal'</span></span><br><span class="line">         <span class="comment">% a = 1; b = 0.25;</span></span><br><span class="line">         varargout&#123;<span class="number">3</span>&#125; = <span class="number">1</span>;</span><br><span class="line">         varargout&#123;<span class="number">4</span>&#125; = <span class="number">0.25</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">'exponential'</span></span><br><span class="line">         <span class="comment">% a = 1.</span></span><br><span class="line">         varargout&#123;<span class="number">3</span>&#125; = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">'erlang'</span></span><br><span class="line">         <span class="comment">% a = 2; b = 5.</span></span><br><span class="line">         varargout&#123;<span class="number">3</span>&#125; = <span class="number">2</span>;</span><br><span class="line">         varargout&#123;<span class="number">4</span>&#125; = <span class="number">5</span>;</span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><strong>周期噪声</strong></p>
<p>imnoise3()，二维正弦波模型</p>
<p>M*N大小，函数接受冲击位置（频率坐标）的一个任意数，每个冲击位置都有自己的振幅，频率，相移参数</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[r, R, S]</span> = <span class="title">imnoise3</span><span class="params">(M, N, C, A, B)</span></span></span><br><span class="line"><span class="comment">%IMNOISE3 Generates periodic noise.</span></span><br><span class="line"><span class="comment">%	[r, R, S] = IMNOISE3(M, N, C, A, B), generates a spatial</span></span><br><span class="line"><span class="comment">%	sinusoidal noise pattern, r, of size M-by-N, its Fourier</span></span><br><span class="line"><span class="comment">%	transform, R, and spectrum, S.  The remaining parameters are:</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">%	C is a K-by-2 matrix with K pairs of frequency domain</span></span><br><span class="line"><span class="comment">%	coordinates (u, v) that define the locations of impulses in the</span></span><br><span class="line"><span class="comment">%	frequency domain. The locations are with respect to the</span></span><br><span class="line"><span class="comment">%	frequency rectangle center at [floor(M/2) + 1, floor(N/2) + 1],</span></span><br><span class="line"><span class="comment">%	where the use of function floor is necessary to guarantee that</span></span><br><span class="line"><span class="comment">%	all values of (u, v) are integers, as required by all Fourier</span></span><br><span class="line"><span class="comment">%	formulations in the book. The impulse locations are specified as</span></span><br><span class="line"><span class="comment">%	integer increments with respect to the center. For example, if M</span></span><br><span class="line"><span class="comment">%	= N = 512, then the center is at (257, 257). To specify an</span></span><br><span class="line"><span class="comment">%	impulse at (280, 300) we specify the pair (23, 43); i.e., 257 +</span></span><br><span class="line"><span class="comment">%	23 = 280, and 257 + 43 = 300. Only one pair of coordinates is</span></span><br><span class="line"><span class="comment">%	required for each impulse. The conjugate pairs are generated</span></span><br><span class="line"><span class="comment">%	automatically.  </span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">%	A is a 1-by-K vector that contains the amplitude of each of the</span></span><br><span class="line"><span class="comment">%	K impulse pairs. If A is not included in the argument, the</span></span><br><span class="line"><span class="comment">%	default used is A = ONES(1, K).  B is then automatically set to</span></span><br><span class="line"><span class="comment">%	its default values (see next paragraph).  The value specified</span></span><br><span class="line"><span class="comment">%	for A(j) is associated with the coordinates in C(j, :). </span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">%	B is a K-by-2 matrix containing the Bx and By phase components</span></span><br><span class="line"><span class="comment">%	for each impulse pair.  The default value for B is zeros(K, 2).</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%   Copyright 2002-2009 R. C. Gonzalez, R. E. Woods, and S. L. Eddins</span></span><br><span class="line"><span class="comment">%   From the book Digital Image Processing Using MATLAB, 2nd ed.,</span></span><br><span class="line"><span class="comment">%   Gatesmark Publishing, 2009.</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">%   Book web site: http://www.imageprocessingplace.com</span></span><br><span class="line"><span class="comment">%   Publisher web site: http://www.gatesmark.com/DIPUM2e.htm</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% Process input parameters.</span></span><br><span class="line">K = <span class="built_in">size</span>(C, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> nargin &lt; <span class="number">4</span></span><br><span class="line">   A = <span class="built_in">ones</span>(<span class="number">1</span>, K);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">if</span> nargin &lt; <span class="number">5</span></span><br><span class="line">   B = <span class="built_in">zeros</span>(K, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% Generate R.</span></span><br><span class="line">R = <span class="built_in">zeros</span>(M, N);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:K</span><br><span class="line">   <span class="comment">% Based on the equation for R(u, v), we know that the first term</span></span><br><span class="line">   <span class="comment">% of R(u, v) associated with a sinusoid is 0 unless u = -u0 and</span></span><br><span class="line">   <span class="comment">% v = -v0:</span></span><br><span class="line">   u1 = <span class="built_in">floor</span>(M/<span class="number">2</span>) + <span class="number">1</span> - C(<span class="built_in">j</span>, <span class="number">1</span>); </span><br><span class="line">   v1 = <span class="built_in">floor</span>(N/<span class="number">2</span>) + <span class="number">1</span> - C(<span class="built_in">j</span>, <span class="number">2</span>);</span><br><span class="line">   R(u1, v1) = <span class="built_in">i</span>*M*N*(A(<span class="built_in">j</span>)/<span class="number">2</span>) * <span class="built_in">exp</span>(-<span class="built_in">i</span>*<span class="number">2</span>*<span class="built_in">pi</span>*(C(<span class="built_in">j</span>, <span class="number">1</span>)*B(<span class="built_in">j</span>, <span class="number">1</span>)/M ...</span><br><span class="line">					+ C(<span class="built_in">j</span>, <span class="number">2</span>)*B(<span class="built_in">j</span>, <span class="number">2</span>)/N));</span><br><span class="line">   <span class="comment">% Conjugate. The second term is zero unless u = u0 and v = v0:</span></span><br><span class="line">   u2 = <span class="built_in">floor</span>(M/<span class="number">2</span>) + <span class="number">1</span> + C(<span class="built_in">j</span>, <span class="number">1</span>); </span><br><span class="line">   v2 = <span class="built_in">floor</span>(N/<span class="number">2</span>) + <span class="number">1</span> + C(<span class="built_in">j</span>, <span class="number">2</span>);</span><br><span class="line">   R(u2, v2) = -<span class="built_in">i</span>*M*N*(A(<span class="built_in">j</span>)/<span class="number">2</span>) * <span class="built_in">exp</span>(<span class="built_in">i</span>*<span class="number">2</span>*<span class="built_in">pi</span>*(C(<span class="built_in">j</span>, <span class="number">1</span>)*B(<span class="built_in">j</span>, <span class="number">1</span>)/M ...</span><br><span class="line">					+ C(<span class="built_in">j</span>, <span class="number">2</span>)*B(<span class="built_in">j</span>, <span class="number">2</span>)/N));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% Compute spectrum and spatial sinusoidal pattern.</span></span><br><span class="line">S = <span class="built_in">abs</span>(R);</span><br><span class="line">r = <span class="built_in">real</span>(ifft2(ifftshift(R)));</span><br></pre></td></tr></table></figure>
<p><strong>估计噪声参数</strong></p>
<p>​        周期噪声往往产生频率尖峰（频率域上的尖峰），而空间域其他类型噪声，通常可以通过样本图像来估计均值和方差，然后来求解a和b。</p>
<p>​        假设$z_i$表示一幅图像的灰度级的一个随机变量，令$p(z_i),i=0,1,2,…,L-1$是相应的归一化直方图。该直方图也可以看成是亮度PDF的一个近似。</p>
<p>​        描述直方图分布形状的一种主要方法是通过它的中心矩</p>
<script type="math/tex; mode=display">
\mu_n=\sum^{L-1}_{i=0}(z_i-m)^np(z_i)</script><p>其中，n是矩的阶，m是均值。</p>
<p>因为假设直方图已经归一化，其所有的分量之和为1，有前面可知$\mu_0=1,\mu_1=0$。二阶矩为：</p>
<script type="math/tex; mode=display">
\mu_2=\sum^{L-1}_{i=0}(z_i-m)^2p(z_i)</script><p>为方差。</p>
<p>函数statmoments()计算均值和n阶中心矩，并返回行向量v。</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%p为直方图向量，n是最多计算的矩的数量，也就是v或者unv的中元素数量</span></span><br><span class="line"><span class="comment">%v包含了归一化矩，unv则是未归一化</span></span><br><span class="line"><span class="comment">%  v(1) = mean, v(2) = variance</span></span><br><span class="line">[v, unv] = statmoments(p, n);</span><br></pre></td></tr></table></figure>
<p>估计噪声（观察法），在一幅图像中选取一个尽可能与背景一样无特色的区域，以便使该区域的亮度值的可变性主要由噪声产生。使用roipoly函数来选择一个感兴趣的区域（ROI），该函数将产生一个多边形的ROI</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% f是原图像，c 和 r 是多边形顶点对应的列坐标和行坐标。</span></span><br><span class="line"><span class="comment">% 输出B是一个二值图像，是一个与f大小相同且在感兴趣的区域外为0，在感兴趣的区域内为1的二值图像</span></span><br><span class="line">B = roipoly(f, c, r);</span><br><span class="line"></span><br><span class="line"><span class="comment">%交互式的指定</span></span><br><span class="line">B = roipoly(f);</span><br><span class="line">[B, c, r] = roipoly(f)</span><br></pre></td></tr></table></figure>
<p><strong>仅有噪声的复原：空间滤波</strong></p>
<p>线性滤波器用imfilter()函数来实现；中值滤波器可以直接用medfilt2()函数实现；最大最小滤波器用ordfilt2()函数实现；</p>
<p>计算线性组合的函数imlincomb()</p>
<script type="math/tex; mode=display">
B=C_1*A_1+C_2*A_2+...+C_k*A_k</script><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">B = imlincomb(C1, A1, C2, A2, ...., Ck, Ak);</span><br></pre></td></tr></table></figure>
<p><img src="17.png" style="zoom:50%;"></p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span> = <span class="title">spfilt</span><span class="params">(g, type, varargin)</span></span></span><br><span class="line"><span class="comment">%SPFILT Performs linear and nonlinear spatial filtering.</span></span><br><span class="line"><span class="comment">%   F = SPFILT(G, TYPE, M, N, PARAMETER) performs spatial filtering</span></span><br><span class="line"><span class="comment">%   of image G using a TYPE filter of size M-by-N. Valid calls to</span></span><br><span class="line"><span class="comment">%   SPFILT are as follows: </span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">%     F = SPFILT(G, 'amean', M, N)       Arithmetic mean filtering.</span></span><br><span class="line"><span class="comment">%     F = SPFILT(G, 'gmean', M, N)       Geometric mean filtering.</span></span><br><span class="line"><span class="comment">%     F = SPFILT(G, 'hmean', M, N)       Harmonic mean filtering.</span></span><br><span class="line"><span class="comment">%     F = SPFILT(G, 'chmean', M, N, Q)   Contraharmonic mean</span></span><br><span class="line"><span class="comment">%                                        filtering of order Q. The</span></span><br><span class="line"><span class="comment">%                                        default Q is 1.5.</span></span><br><span class="line"><span class="comment">%     F = SPFILT(G, 'median', M, N)      Median filtering.</span></span><br><span class="line"><span class="comment">%     F = SPFILT(G, 'max', M, N)         Max filtering.</span></span><br><span class="line"><span class="comment">%     F = SPFILT(G, 'min', M, N)         Min filtering.</span></span><br><span class="line"><span class="comment">%     F = SPFILT(G, 'midpoint', M, N)    Midpoint filtering.</span></span><br><span class="line"><span class="comment">%     F = SPFILT(G, 'atrimmed', M, N, D) Alpha-trimmed mean </span></span><br><span class="line"><span class="comment">%                                        filtering. Parameter D must </span></span><br><span class="line"><span class="comment">%                                        be a nonnegative even </span></span><br><span class="line"><span class="comment">%                                        integer; its default value </span></span><br><span class="line"><span class="comment">%                                        is 2.</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">%   The default values when only G and TYPE are input are M = N = 3,</span></span><br><span class="line"><span class="comment">%   Q = 1.5, and D = 2. </span></span><br><span class="line"></span><br><span class="line"><span class="comment">%   Copyright 2002-2009 R. C. Gonzalez, R. E. Woods, and S. L. Eddins</span></span><br><span class="line"><span class="comment">%   From the book Digital Image Processing Using MATLAB, 2nd ed.,</span></span><br><span class="line"><span class="comment">%   Gatesmark Publishing, 2009.</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">%   Book web site: http://www.imageprocessingplace.com</span></span><br><span class="line"><span class="comment">%   Publisher web site: http://www.gatesmark.com/DIPUM2e.htm</span></span><br><span class="line"></span><br><span class="line">[m, n, Q, d] = processInputs(varargin&#123;:&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">% Do the filtering.</span></span><br><span class="line"><span class="keyword">switch</span> <span class="built_in">type</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">'amean'</span></span><br><span class="line">   w = fspecial(<span class="string">'average'</span>, [m n]);</span><br><span class="line">   f = imfilter(g, w, <span class="string">'replicate'</span>);</span><br><span class="line"><span class="keyword">case</span> <span class="string">'gmean'</span></span><br><span class="line">   f = gmean(g, m, n);</span><br><span class="line"><span class="keyword">case</span> <span class="string">'hmean'</span></span><br><span class="line">   f = harmean(g, m, n);</span><br><span class="line"><span class="keyword">case</span> <span class="string">'chmean'</span></span><br><span class="line">   f = charmean(g, m, n, Q);</span><br><span class="line"><span class="keyword">case</span> <span class="string">'median'</span></span><br><span class="line">   f = medfilt2(g, [m n], <span class="string">'symmetric'</span>);</span><br><span class="line"><span class="keyword">case</span> <span class="string">'max'</span></span><br><span class="line">   f = imdilate(g, <span class="built_in">ones</span>(m, n));</span><br><span class="line"><span class="keyword">case</span> <span class="string">'min'</span></span><br><span class="line">   f = imerode(g, <span class="built_in">ones</span>(m, n));</span><br><span class="line"><span class="keyword">case</span> <span class="string">'midpoint'</span></span><br><span class="line">   f1 = ordfilt2(g, <span class="number">1</span>, <span class="built_in">ones</span>(m, n), <span class="string">'symmetric'</span>);</span><br><span class="line">   f2 = ordfilt2(g, m*n, <span class="built_in">ones</span>(m, n), <span class="string">'symmetric'</span>);</span><br><span class="line">   f = imlincomb(<span class="number">0.5</span>, f1, <span class="number">0.5</span>, f2);</span><br><span class="line"><span class="keyword">case</span> <span class="string">'atrimmed'</span></span><br><span class="line">   f = alphatrim(g, m, n, d);</span><br><span class="line"><span class="keyword">otherwise</span></span><br><span class="line">   error(<span class="string">'Unknown filter type.'</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%------------------------------------------------------------------%</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span> = <span class="title">gmean</span><span class="params">(g, m, n)</span></span></span><br><span class="line"><span class="comment">%  Implements a geometric mean filter.</span></span><br><span class="line">[g, revertClass] = tofloat(g);</span><br><span class="line">f = <span class="built_in">exp</span>(imfilter(<span class="built_in">log</span>(g), <span class="built_in">ones</span>(m, n), <span class="string">'replicate'</span>)).^(<span class="number">1</span> / m / n);</span><br><span class="line">f = revertClass(f);</span><br><span class="line"></span><br><span class="line"><span class="comment">%------------------------------------------------------------------%</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span> = <span class="title">harmean</span><span class="params">(g, m, n)</span></span></span><br><span class="line"><span class="comment">%  Implements a harmonic mean filter.</span></span><br><span class="line">[g, revertClass] = tofloat(g);</span><br><span class="line">f = m * n ./ imfilter(<span class="number">1.</span>/(g + <span class="built_in">eps</span>),<span class="built_in">ones</span>(m, n), <span class="string">'replicate'</span>);</span><br><span class="line">f = revertClass(f);</span><br><span class="line"></span><br><span class="line"><span class="comment">%------------------------------------------------------------------%</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span> = <span class="title">charmean</span><span class="params">(g, m, n, q)</span></span></span><br><span class="line"><span class="comment">%  Implements a contraharmonic mean filter.</span></span><br><span class="line">[g, revertClass] = tofloat(g);</span><br><span class="line">f = imfilter(g.^(q+<span class="number">1</span>), <span class="built_in">ones</span>(m, n), <span class="string">'replicate'</span>);</span><br><span class="line">f = f ./ (imfilter(g.^q, <span class="built_in">ones</span>(m, n), <span class="string">'replicate'</span>) + <span class="built_in">eps</span>);</span><br><span class="line">f = revertClass(f);</span><br><span class="line"></span><br><span class="line"><span class="comment">%------------------------------------------------------------------%</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span> = <span class="title">alphatrim</span><span class="params">(g, m, n, d)</span></span></span><br><span class="line"><span class="comment">%  Implements an alpha-trimmed mean filter.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (d &lt;= <span class="number">0</span>) || (d/<span class="number">2</span> ~= <span class="built_in">round</span>(d/<span class="number">2</span>))</span><br><span class="line">   error(<span class="string">'d must be a positive, even integer.'</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">[g, revertClass] = tofloat(g);</span><br><span class="line">f = imfilter(g, <span class="built_in">ones</span>(m, n), <span class="string">'symmetric'</span>);</span><br><span class="line"><span class="keyword">for</span> k = <span class="number">1</span>:d/<span class="number">2</span></span><br><span class="line">   f = f - ordfilt2(g, k, <span class="built_in">ones</span>(m, n), <span class="string">'symmetric'</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> k = (m*n - (d/<span class="number">2</span>) + <span class="number">1</span>):m*n</span><br><span class="line">   f = f - ordfilt2(g, k, <span class="built_in">ones</span>(m, n), <span class="string">'symmetric'</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">f = f / (m*n - d);</span><br><span class="line">f = revertClass(f);</span><br><span class="line"></span><br><span class="line"><span class="comment">%------------------------------------------------------------------%</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[m, n, Q, d]</span> = <span class="title">processInputs</span><span class="params">(varargin)</span></span></span><br><span class="line"></span><br><span class="line">m = <span class="number">3</span>;</span><br><span class="line">n = <span class="number">3</span>;</span><br><span class="line">Q = <span class="number">1.5</span>;</span><br><span class="line">d = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> nargin &gt; <span class="number">0</span></span><br><span class="line">   m = varargin&#123;<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> nargin &gt; <span class="number">1</span></span><br><span class="line">   n = varargin&#123;<span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> nargin &gt; <span class="number">2</span></span><br><span class="line">   Q = varargin&#123;<span class="number">3</span>&#125;;</span><br><span class="line">   d = varargin&#123;<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><strong>自适应空间滤波器</strong></p>
<p>aadpmedian()自适应中值滤波；g是将要被滤波的图像，Smax是允许的最大自适应滤波器窗口大小</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span> = <span class="title">adpmedian</span><span class="params">(g, Smax)</span></span></span><br><span class="line"><span class="comment">%ADPMEDIAN Perform adaptive median filtering.</span></span><br><span class="line"><span class="comment">%   F = ADPMEDIAN(G, SMAX) performs adaptive median filtering of</span></span><br><span class="line"><span class="comment">%   image G.  The median filter starts at size 3-by-3 and iterates</span></span><br><span class="line"><span class="comment">%   up to size SMAX-by-SMAX. SMAX must be an odd integer greater</span></span><br><span class="line"><span class="comment">%   than 1.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%   Copyright 2002-2009 R. C. Gonzalez, R. E. Woods, and S. L. Eddins</span></span><br><span class="line"><span class="comment">%   From the book Digital Image Processing Using MATLAB, 2nd ed.,</span></span><br><span class="line"><span class="comment">%   Gatesmark Publishing, 2009.</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">%   Book web site: http://www.imageprocessingplace.com</span></span><br><span class="line"><span class="comment">%   Publisher web site: http://www.gatesmark.com/DIPUM2e.htm</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% SMAX must be an odd, positive integer greater than 1.</span></span><br><span class="line"><span class="keyword">if</span> (Smax &lt;= <span class="number">1</span>) || (Smax/<span class="number">2</span> == <span class="built_in">round</span>(Smax/<span class="number">2</span>)) || (Smax ~= <span class="built_in">round</span>(Smax))</span><br><span class="line">   error(<span class="string">'SMAX must be an odd integer &gt; 1.'</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% Initial setup.</span></span><br><span class="line">f = g;</span><br><span class="line">f(:) = <span class="number">0</span>;</span><br><span class="line">alreadyProcessed = <span class="built_in">false</span>(<span class="built_in">size</span>(g));</span><br><span class="line"></span><br><span class="line"><span class="comment">% Begin filtering.</span></span><br><span class="line"><span class="keyword">for</span> k = <span class="number">3</span>:<span class="number">2</span>:Smax</span><br><span class="line">   zmin = ordfilt2(g, <span class="number">1</span>, <span class="built_in">ones</span>(k, k), <span class="string">'symmetric'</span>);</span><br><span class="line">   zmax = ordfilt2(g, k * k, <span class="built_in">ones</span>(k, k), <span class="string">'symmetric'</span>);</span><br><span class="line">   zmed = medfilt2(g, [k k], <span class="string">'symmetric'</span>);</span><br><span class="line">   </span><br><span class="line">   processUsingLevelB = (zmed &gt; zmin) &amp; (zmax &gt; zmed) &amp; ...</span><br><span class="line">       ~alreadyProcessed; </span><br><span class="line">   zB = (g &gt; zmin) &amp; (zmax &gt; g);</span><br><span class="line">   outputZxy  = processUsingLevelB &amp; zB;</span><br><span class="line">   outputZmed = processUsingLevelB &amp; ~zB;</span><br><span class="line">   f(outputZxy) = g(outputZxy);</span><br><span class="line">   f(outputZmed) = zmed(outputZmed);</span><br><span class="line">   </span><br><span class="line">   alreadyProcessed = alreadyProcessed | processUsingLevelB;</span><br><span class="line">   <span class="keyword">if</span> all(alreadyProcessed(:))</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% Output zmed for any remaining unprocessed pixels. Note that this</span></span><br><span class="line"><span class="comment">% zmed was computed using a window of size Smax-by-Smax, which is</span></span><br><span class="line"><span class="comment">% the final value of k in the loop.</span></span><br><span class="line">f(~alreadyProcessed) = zmed(~alreadyProcessed);</span><br></pre></td></tr></table></figure>
<p><strong>退化函数建模</strong></p>
<p>对于相对均匀线性运动导致的图像模糊，可以使用fspecial()函数对图像模糊建模：</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%返回PSF，它近似于有着len个像素的摄像机的线性移动的效果（默认9），theta以度为单位，以顺时针方向对正水平轴度</span></span><br><span class="line"><span class="comment">%量（默认0）</span></span><br><span class="line">PSF = fspecial(<span class="string">'motion'</span>, len, theta);<span class="comment">%PSF 表示point spread function，点扩散函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% checkerboard()函数，产生一个测试版，左边亮正方形是白色的，右边亮正方形是灰色的</span></span><br><span class="line"><span class="comment">% NP是每个正方形一边的像素数（10），M是行数（8），N是列数（M）</span></span><br><span class="line">c = checkerboard(NP, M, N);</span><br><span class="line"><span class="comment">%产生亮方块全是白色的测试板</span></span><br><span class="line">c = im2double(checkerboard(<span class="number">100</span>)&gt;<span class="number">0.5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">%通过像素复制来放大图像，作用，有时候可以先用小图像来处理，处理完了再放大看效果</span></span><br><span class="line"><span class="comment">% A是原图像，m垂直方向，n水平方向（m）</span></span><br><span class="line">B = pixeldup(A, m, n);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span> = <span class="title">pixeldup</span><span class="params">(A, m, n)</span></span></span><br><span class="line"><span class="comment">%PIXELDUP Duplicates pixels of an image in both directions.</span></span><br><span class="line"><span class="comment">%   B = PIXELDUP(A, M, N) duplicates each pixel of A M times in the</span></span><br><span class="line"><span class="comment">%   vertical direction and N times in the horizontal direction.</span></span><br><span class="line"><span class="comment">%   Parameters M and N must be integers.  If N is not included, it</span></span><br><span class="line"><span class="comment">%   defaults to M.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%   Copyright 2002-2009 R. C. Gonzalez, R. E. Woods, and S. L. Eddins</span></span><br><span class="line"><span class="comment">%   From the book Digital Image Processing Using MATLAB, 2nd ed.,</span></span><br><span class="line"><span class="comment">%   Gatesmark Publishing, 2009.</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">%   Book web site: http://www.imageprocessingplace.com</span></span><br><span class="line"><span class="comment">%   Publisher web site: http://www.gatesmark.com/DIPUM2e.htm</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% Check inputs.</span></span><br><span class="line"><span class="keyword">if</span> nargin &lt; <span class="number">2</span> </span><br><span class="line">   error(<span class="string">'At least two inputs are required.'</span>); </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">if</span> nargin == <span class="number">2</span> </span><br><span class="line">   n = m; </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% Generate a vector with elements 1:size(A, 1).</span></span><br><span class="line">u = <span class="number">1</span>:<span class="built_in">size</span>(A, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% Duplicate each element of the vector m times.</span></span><br><span class="line">m = <span class="built_in">round</span>(m); <span class="comment">% Protect against nonintegers.</span></span><br><span class="line">u = u(<span class="built_in">ones</span>(<span class="number">1</span>, m), :);</span><br><span class="line">u = u(:);</span><br><span class="line"></span><br><span class="line"><span class="comment">% Now repeat for the other direction.</span></span><br><span class="line">v = <span class="number">1</span>:<span class="built_in">size</span>(A, <span class="number">2</span>);</span><br><span class="line">n = <span class="built_in">round</span>(n);</span><br><span class="line">v = v(<span class="built_in">ones</span>(<span class="number">1</span>, n), :);</span><br><span class="line">v = v(:);</span><br><span class="line">B = A(u, v);</span><br></pre></td></tr></table></figure>
<p><strong>维纳滤波</strong></p>
<p>维纳滤波使用函数deconvwnr()来实现的</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% g表示退化图像， fr是复原图像，假设信噪比为0的情况</span></span><br><span class="line">fr = deconvwnr(g, PSF);</span><br><span class="line"></span><br><span class="line"><span class="comment">%假设信噪比已知</span></span><br><span class="line">fr = deconvwnr(g, PSF, NSPR);</span><br><span class="line"></span><br><span class="line"><span class="comment">%假设噪声和未退化的自相关函数是已知的</span></span><br><span class="line">fr = deconvwnr(g, PSF, NACORR, FACORR);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 为了避免振铃现象，通常要使用如下函数，在后面的操作中通用</span></span><br><span class="line"><span class="comment">% 该函数利用点扩散函数PSF模糊了输入图像I的边缘，这样J就是I和I的模糊版本的加权和</span></span><br><span class="line">J = edgetaper(I, PSF);</span><br></pre></td></tr></table></figure>
<p><img src="18.png" style="zoom:50%;"></p>
<p><img src="19.png" style="zoom:50%;"></p>
<p><strong>约束的最小二乘方（正则）滤波</strong></p>
<p>通过函数deconveg()实现</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% g是被污染的图像，fr是复原的图像，NOISEPOWER与约束条件成比例，RANGE为值的范围</span></span><br><span class="line">fr = deconveg(g, PSF, NOISEPOWER, RANGE);</span><br></pre></td></tr></table></figure>
<p><strong>使用Lucy-Richardson算法的迭代非线性复原</strong></p>
<p>详情见教材Matlab版P130</p>
<p>deconvlucy()函数</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fr = deconvlucy(g, PSF, NUMIT, DAMPAR, WEIGHT);</span><br></pre></td></tr></table></figure>
<p><strong>盲去卷积</strong></p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% g表示退化图像，INITPSE是点扩散函数的初始估计，PSFe是这个函数计算得到的估计值。fr是利用估计</span></span><br><span class="line"><span class="comment">% 的PSF复原的图像。</span></span><br><span class="line">[fr, PSFe] = deconvblind(g, INITPSE);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 该语法可控制迭代次数</span></span><br><span class="line">[fr, PSFe] = deconvblind(g, INITPSE, NUMIT, DAMPAR, WEIGHT);</span><br></pre></td></tr></table></figure>
<p><strong>几何变换与图像配准</strong></p>
<p>IPT利用一个所谓的tform结构来表示空间结构，创建这个结构的一个方法是利用函数makeform</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tform = makeform(transform_type, transform_parameters);</span><br></pre></td></tr></table></figure>
<p><img src="20.png" style="zoom:60%;"></p>
<p>创建仿射变换tform的一种途径就是直接提供<strong>矩阵T</strong></p>
<p>IPT提供两个用于对点进行空间变换的函数：tformfwd计算正变换$T\{(w,z)\}$，tforminv计算逆变换$T^{-1}\{(w,z)\}$。</p>
<p><strong>空间变换</strong></p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g = imtransform(f, tform, interp);</span><br></pre></td></tr></table></figure>
<p><strong>图像配准</strong></p>
<p>cp2tform函数</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://dongxh.cn/2020/03/24/图像复原/" data-id="ck8l56qpz0018tmlk3iiocvji" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数字图像处理/">数字图像处理</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-频域的图像增强" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/19/频域的图像增强/" class="article-date">
  <time datetime="2020-03-19T14:00:42.000Z" itemprop="datePublished">2020-03-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Digital-Image-Process/">Digital Image Process</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/19/频域的图像增强/">频域的图像增强</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="频域的图像增强"><a href="#频域的图像增强" class="headerlink" title="频域的图像增强"></a>频域的图像增强</h1><h2 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h2><h3 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h3><ul>
<li>一维离散傅里叶变换及反变换  <script type="math/tex; mode=display">
F(u)= \sum_{x=0}^{M-1}f(x)e^{-j2\pi ux/M}</script></li>
</ul>
<script type="math/tex; mode=display">
f(x)=\frac{1 }{M}\sum_{u=0}^{M-1}F(u)e^{j2\pi ux/M}</script><ul>
<li>二维离散傅里叶变换及反变换<script type="math/tex; mode=display">
F(u,v)= \sum_{x=0}^{M-1} \sum_{y=0}^{N-1} f(x,y)e^{-j2\pi (ux/M+vy/N)}</script></li>
</ul>
<script type="math/tex; mode=display">
f(x,y)=\frac{1 }{MN}\sum_{u=0}^{M-1} \sum_{v=0}^{N-1}F(u,v)e^{j2\pi (ux/M+vy/N)}</script><p><strong>二维傅里叶变换的性质</strong></p>
<p>1.平移特性</p>
<script type="math/tex; mode=display">
f(x-x_0,y-y_0)\Leftrightarrow F(u,v)e^{j2\pi (ux_0/M+vy_0/N)}\ \ \ \ \ \ \ \ (1)</script><script type="math/tex; mode=display">
f(x,y)e^{j2\pi (u_0x/M+v_0y/N)}\Leftrightarrow F(u-u_0,v-v_0)\ \ \ \ \ \ \ \ (2)</script><p>公式(1)表明了对原图进行平移操作，其傅里叶变换的幅值不变。</p>
<p>公式(2)表明了将原图乘以一个指数项，等于将其频域图平移。</p>
<p>利用这一性质我们可以对图像进行<strong>原点平移</strong>，通常我们将傅里叶变换的后的图像原点放置在坐标系中的中心位置，即(M/2,N/2)。则$u_0=M/2,v_0=N/2$，得到图像函数所乘的指数项为$(-1)^{x+y}$.</p>
<script type="math/tex; mode=display">
f(x,y)(-1)^{x+y}\Leftrightarrow F(u-M/2,v-N/2)</script><p>2.旋转性</p>
<p>引入极坐标：$x=r\ cos\theta,\ y=r\ sin\theta,u=\omega\ cos\varphi,v=\omega\ sin\varphi$ .</p>
<script type="math/tex; mode=display">
f(r,\theta +\theta _0)\Leftrightarrow F(\omega ,\varphi +\theta _0)\ \ \ \ \ \ \ \ (3)</script><p>公式(3)表明$f(x,y)$转过同样的角度，$F(u,v)$也转过同样的角度，反正亦然。</p>
<p>3.周期性</p>
<p>类似于循环位移性质，不过是二维的。</p>
<p>4.共轭对称性</p>
<p>傅里叶变换的频率谱是关于原点对称的。</p>
<p>5.分离性</p>
<script type="math/tex; mode=display">
F(u,v)=\frac{1}{M}\sum_{x=0}^{M-1}e^{-j2\pi ux/M}\frac{1}{N}\sum_{y=0}^{N-1}f(x,y)e^{-j2\pi vy/N}</script><script type="math/tex; mode=display">
\ \ \ =F(u,v)=\frac{1}{M}\sum_{x=0}^{M-1}e^{-j2\pi ux/M}F(x,v)</script><p><strong>快速傅里叶变换</strong></p>
<p>FFT与原始算法的计算量之比为$log_2M/M$。</p>
<p>​        1.在运用FFT时，通常需要把图像扩展到$2^n$大小；</p>
<p>​        2.在做两幅图像的卷积或者相关性运算时，如果两幅图片大小不一致（即两个函数周期不一致），也需要扩展尺寸较小的那一幅图像。</p>
<h3 id="频率域滤波基础"><a href="#频率域滤波基础" class="headerlink" title="频率域滤波基础"></a>频率域滤波基础</h3><p>一般来说，低频分量对应图像中变化慢的区域，而高频分量对应图像中灰度变化快的区域（边缘，噪声等）。</p>
<p>频率域滤波的步骤：</p>
<ol>
<li>$(-1)^{x+y}$乘以原图像</li>
<li>$DFT$</li>
<li>$H(u,v)\times F(u,v)$</li>
<li>$IDFT$</li>
<li>实部</li>
<li>用$(-1)^{x+y}\times$(5)的结果</li>
</ol>
<p><img src="1.png" style="zoom: 67%;"></p>
<p>为什么要取实部呢？如果输入图像和滤波函数都是实数函数，那么理想情况下，滤波后的反傅里叶变换的虚部应该是0.但是，由于傅里叶变换计算上的舍入等误差，反傅里叶变换一般有寄生的虚部成分，不过这些虚部成分可以忽略。</p>
<h3 id="平滑的频率域滤波器（低通）"><a href="#平滑的频率域滤波器（低通）" class="headerlink" title="平滑的频率域滤波器（低通）"></a>平滑的频率域滤波器（低通）</h3><p><strong>平滑滤波器</strong>：一般指的就是低通滤波器，将高频分量抑制来实现平滑滤波。</p>
<p>应用：可以用于平滑处理，如图像由于量化不足（灰度分辨率不够）时产生的虚假轮廓。同时可以用于去除噪声。</p>
<h4 id="理想低通滤波器"><a href="#理想低通滤波器" class="headerlink" title="理想低通滤波器"></a><strong>理想低通滤波器</strong></h4><p><strong>（Ideal Lowpass Filter）</strong></p>
<p>截断$F(u,v)$中的频率处于指定距离$D_0$（截止频率）之外的所有高频成分。</p>
<script type="math/tex; mode=display">
H(u,v)=\left\{\begin{matrix}
1 &if\ D(u,v)\leqslant D_0 \\ 
 0&if\ D(u,v)>D_0 
\end{matrix}\right.</script><p>$D(u,v)$是点$(u,v)$距频率原点的距离，其中$D(u,v)=\sqrt{(u-M/2)^2+(v-N/2)^2}$ .</p>
<p>因为中心化后，频域原点在频谱图的中心，所以中心点是常量也就是平均值，越往边上移动，频率就会越高。</p>
<p><img src="2.png" style="zoom:45%;"></p>
<p>振铃现象十分显著：</p>
<p><img src="4.png" style="zoom:50%;"></p>
<p>问题：如何确定截止频率？</p>
<p>答：根据截止频率为半径的圆内所包含的功率值，来选择相应的截止频率。</p>
<h4 id="巴特沃斯低通滤波器"><a href="#巴特沃斯低通滤波器" class="headerlink" title="巴特沃斯低通滤波器"></a><strong>巴特沃斯低通滤波器</strong></h4><p><strong>（Butterworth Lowpass Filter）</strong></p>
<script type="math/tex; mode=display">H(u,v)=\frac{1}{1+[D(u,v)/D_0]^{2n}}</script><p>n代表滤波器阶数。当$D(u,v)=D_0$时，$H(u,v)=0.5$;</p>
<p><img src="3.png" style="zoom: 60%;"></p>
<p>二阶BLPF处于有效低通滤波和可接受的振铃特征之间：</p>
<p><img src="5.png" style="zoom:50%;"></p>
<h4 id="高斯低通滤波器"><a href="#高斯低通滤波器" class="headerlink" title="高斯低通滤波器"></a><strong>高斯低通滤波器</strong></h4><p><strong>（Gaussian Lowpass Filters）</strong></p>
<script type="math/tex; mode=display">H(u,v)=e^{-D^2(u,v)/2D_0^2}</script><p>其中$D_0$为截止频率，当$D(u,v)=D_0$时，滤波器下降到其最大值的0.607处。无振铃现象，曲线如下：</p>
<p><img src="6.png" style="zoom:44%;"></p>
<h4 id="低通滤波器的应用实例"><a href="#低通滤波器的应用实例" class="headerlink" title="低通滤波器的应用实例"></a>低通滤波器的应用实例</h4><p>字符识别：通过模糊图像，桥接断裂字符的裂缝等；</p>
<p>印刷和出版社：从一幅尖锐的原始图像产生平滑，柔和的外观，如人脸，减少皮肤细纹的锐化程度和小斑点；</p>
<p>处理卫星和航空图像：尽可能模糊细节，而保留大的可识别特征。低通滤波器通过消除不重要的特征来简化感兴趣的特征的分析；</p>
<p><img src="7.png" style="zoom:50%;"></p>
<p><img src="8.png" style="zoom: 45%;"></p>
<p><img src="9.png" style="zoom:50%;"></p>
<h3 id="频率域锐化处理"><a href="#频率域锐化处理" class="headerlink" title="频率域锐化处理"></a>频率域锐化处理</h3><h4 id="IHPF-GHPF-BHPF"><a href="#IHPF-GHPF-BHPF" class="headerlink" title="IHPF,GHPF,BHPF"></a>IHPF,GHPF,BHPF</h4><p>高通滤波器可直接用上面的结论取反；</p>
<p><img src="10.png" style="zoom:50%;"></p>
<p><img src="12.png" style="zoom:50%;"></p>
<p><img src="/Users/dongxuehui/Desktop/数字图像处理/note/DIP_ch03/11.png" alt></p>
<h4 id="拉普拉斯算子"><a href="#拉普拉斯算子" class="headerlink" title="拉普拉斯算子"></a>拉普拉斯算子</h4><p>公式过程略，详情见教材相关内容；</p>
<p><img src="13.png" style="zoom:50%;"></p>
<p>效果图：</p>
<p><img src="14.png" style="zoom:50%;"></p>
<h4 id="高频增强滤波"><a href="#高频增强滤波" class="headerlink" title="高频增强滤波"></a>高频增强滤波</h4><p>高频增强滤波是在高通滤波器上再加一个常数使得低频信号也能过去实现的。</p>
<p><img src="15.png" style="zoom:50%;"></p>
<p>图一为原图；图二为高斯高通滤波后的结果；图三是图一和图二组合起来的结果；图四为直方图均衡化结果；</p>
<h3 id="带通带阻滤波器"><a href="#带通带阻滤波器" class="headerlink" title="带通带阻滤波器"></a>带通带阻滤波器</h3><p><strong>带阻滤波器</strong></p>
<p>阻止一定频率的信号（允许其他频率范围信号），旋转对称；</p>
<p><img src="16.png" style="zoom:50%;"></p>
<p><img src="17.png" style="zoom:50%;"></p>
<p><strong>带通滤波器</strong></p>
<p>在带阻滤波器基础上变换。</p>
<h4 id="同态滤波器"><a href="#同态滤波器" class="headerlink" title="同态滤波器"></a>同态滤波器</h4><p><strong>频域滤波可以灵活地解决加性噪声问题，但无法消减乘性或卷积性噪声。</strong></p>
<p>​        同态滤波器是在频域中同时压缩动态（灰度）范围并增强局部对比度，来实现图像增强的方法。</p>
<p>​        为了分离加性组合的信号，常采用线性滤波的方法，而非加性信号组合常用同态滤波的技术将非线性问题转化成线性问题处理，即先对非线性（乘性或者卷积性）混杂信号作某种数学运算，变换成加性的。然后用线性滤波方法处理，最后作反变换运算,恢复处理后图像。</p>
<p>假如在阳光灿烂的风景照中，由于底片的动态范围比较窄，照片中的对比度要降低很多。这个现象在亮区或者暗区尤其明显。</p>
<p>照射反射模型,</p>
<script type="math/tex; mode=display">
f(x,y)=i(x,y)r(x,y)</script><p>一般假定入射光的动态范围很大并且变化缓慢，而反射光部分变化迅速，它确定了图的细节和局部的对比度。因此补救方法应该是减少$i(x,y)$并同时增加$r(x,y)$，</p>
<p>因为乘积的傅里叶变换不是变换的乘积，</p>
<script type="math/tex; mode=display">
\mathfrak{F}[f(x,y)]\neq \mathfrak{F}[i(x,y)]\ \mathfrak{F}[r(x,y)]</script><p>对模型两边取对数，再变换，</p>
<script type="math/tex; mode=display">
\mathfrak{F}\{z(x,y)\}= \mathfrak{F}\{ln\ f(x,y)\}= \mathfrak{F}\{ln\ i(x,y)\}+\mathfrak{F}\{ln\ r(x,y)\}</script><p>而后步骤详情请见教材。</p>
<p>同态滤波步骤小结：</p>
<p><img src="18.png" style="zoom:50%;"></p>
<p>一般来说，图片照射分量往往以空间域的慢变化为特征，而反射分量往往发生突变，尤其是在不同物体的连接部分。导致傅里叶变换： </p>
<script type="math/tex; mode=display">
H(u,v)\ \Leftrightarrow\  \xrightarrow[高频\rightarrow反射]{低频\rightarrow 照射}</script><p>函数形状可用稍微变形一下的高斯高通滤波器来近似；</p>
<script type="math/tex; mode=display">
D(u,v)=[(u-P/2)^2+(v-Q/2)^2]^{1/2}
\\ \ 
\\ \ 
\\
H(u,v)=(\gamma_H-\gamma_L)[1-e^{-c[D^2(u,v)/D_0^2]}]+\gamma_L</script><p>常数$C$控制函数坡度的锐利度，它在$\gamma_L$和$\gamma_H$之间过渡，$\gamma_L<1$而$\gamma_h>1$。下图为圆形对称的径向剖面图。</1$而$\gamma_h></p>
<p><img src="19.png" style="zoom:50%;"></p>
<h2 id="Matlab实现"><a href="#Matlab实现" class="headerlink" title="Matlab实现"></a>Matlab实现</h2><h4 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h4><p>中心化</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Y = fftshift(X)；<span class="comment">%通过将零频分量移动到数组中心，重新排列傅里叶变换 X。</span></span><br><span class="line"></span><br><span class="line">X = ifftshift(Y);<span class="comment">%去中心化</span></span><br></pre></td></tr></table></figure>
<p>计算并可视化二维DFT</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Y = fft2(X);</span><br><span class="line">Y = fft2(X, m, n);<span class="comment">%表示函数将用0来填充原矩阵到m*n矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%例子，显示图像的频谱图</span></span><br><span class="line">F = fft2(f);        <span class="comment">%二维傅里叶变换</span></span><br><span class="line">Fc = fftshift(F);   <span class="comment">%中心化频谱图</span></span><br><span class="line">Sc = <span class="built_in">abs</span>(Fc);       <span class="comment">%取模</span></span><br><span class="line">S2 = <span class="built_in">log</span>(<span class="number">1</span> + Sc);   <span class="comment">%对数变换</span></span><br><span class="line">imshow(S2, []);     <span class="comment">%[]不能漏</span></span><br></pre></td></tr></table></figure>
<p>傅里叶逆变换</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f = ifft2(F);</span><br><span class="line"><span class="comment">%说明，若用于计算F的输入f为实数，则理论上逆变换的结果也应该是实数，</span></span><br><span class="line"><span class="comment">%但是由于计算机的浮点运算的舍入误差，实际结果可能会有很小的虚部分量，</span></span><br><span class="line"><span class="comment">%因此，最好在计算逆变换提取结果实部.</span></span><br><span class="line">f = <span class="built_in">real</span>(ifft2(F));</span><br></pre></td></tr></table></figure>
<p>空间滤波实际上和频域滤波是对等的，空间滤波的掩模是进行卷积运算，而频域滤波是进行乘法运算；实际上，空间卷积通常使用较小的掩模来简化，使用这种较小掩模的目的是尽可能的获得其频域对应内容的显著特征。</p>
<p>值得注意的是：</p>
<p><img src="20.png" style="zoom:50%;"></p>
<p>用函数paddedsize可以用于计算满足前述等式P和Q的最小偶数值的运算。</p>
<p>注意，在频域进行填充时，滤波器的大小必须为PQ(1) x PQ(2)。</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PQ</span> = <span class="title">paddedsize</span><span class="params">(AB, CD, PARAM)</span></span></span><br><span class="line"><span class="comment">%PADDEDSIZE Computes padded sizes useful for FFT-based filtering. </span></span><br><span class="line"><span class="comment">%   PQ = PADDEDSIZE(AB), where AB is a two-element size vector,</span></span><br><span class="line"><span class="comment">%   computes the two-element size vector PQ = 2*AB.</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">%   PQ = PADDEDSIZE(AB, 'PWR2') computes the vector PQ such that</span></span><br><span class="line"><span class="comment">%   PQ(1) = PQ(2) = 2^nextpow2(2*m), where m is MAX(AB).</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">%   PQ = PADDEDSIZE(AB, CD), where AB and CD are two-element size</span></span><br><span class="line"><span class="comment">%   vectors, computes the two-element size vector PQ.  The elements</span></span><br><span class="line"><span class="comment">%   of PQ are the smallest even integers greater than or equal to </span></span><br><span class="line"><span class="comment">%   AB + CD - 1.</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">%   PQ = PADDEDSIZE(AB, CD, 'PWR2') computes the vector PQ such that</span></span><br><span class="line"><span class="comment">%   PQ(1) = PQ(2) = 2^nextpow2(2*m), where m is MAX([AB CD]). </span></span><br><span class="line"></span><br><span class="line"><span class="comment">%   Copyright 2002-2009 R. C. Gonzalez, R. E. Woods, and S. L. Eddins</span></span><br><span class="line"><span class="comment">%   From the book Digital Image Processing Using MATLAB, 2nd ed.,</span></span><br><span class="line"><span class="comment">%   Gatesmark Publishing, 2009.</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">%   Book web site: http://www.imageprocessingplace.com</span></span><br><span class="line"><span class="comment">%   Publisher web site: http://www.gatesmark.com/DIPUM2e.htm</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> nargin == <span class="number">1</span></span><br><span class="line">   PQ  = <span class="number">2</span>*AB;</span><br><span class="line"><span class="keyword">elseif</span> nargin == <span class="number">2</span> &amp;&amp; ~ischar(CD)</span><br><span class="line">   PQ = AB + CD - <span class="number">1</span>;</span><br><span class="line">   PQ = <span class="number">2</span> * <span class="built_in">ceil</span>(PQ / <span class="number">2</span>);</span><br><span class="line"><span class="keyword">elseif</span> nargin == <span class="number">2</span></span><br><span class="line">   m = <span class="built_in">max</span>(AB); <span class="comment">% Maximum dimension.</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">% Find power-of-2 at least twice m.</span></span><br><span class="line">   P = <span class="number">2</span>^<span class="built_in">nextpow2</span>(<span class="number">2</span>*m);</span><br><span class="line">   PQ = [P, P];</span><br><span class="line"><span class="keyword">elseif</span> (nargin == <span class="number">3</span>) &amp;&amp; strcmpi(PARAM, <span class="string">'pwr2'</span>)</span><br><span class="line">   m = <span class="built_in">max</span>([AB CD]); <span class="comment">% Maximum dimension.</span></span><br><span class="line">   P = <span class="number">2</span>^<span class="built_in">nextpow2</span>(<span class="number">2</span>*m);</span><br><span class="line">   PQ = [P, P];</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">   error(<span class="string">'Wrong number of inputs.'</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">%通过使用函数paddedsize计算后的PQ，然后再用fft2来计算经0填充后的FFT</span></span><br><span class="line">F = fft2(f, PQ(<span class="number">1</span>), PQ(<span class="number">2</span>));</span><br></pre></td></tr></table></figure>
<p>DFT滤波基本步骤：</p>
<p><img src="1.png" style="zoom:70%;"></p>
<ol>
<li><p>使用函数<code>paddesize</code>获得填充参数</p>
<p><code>PQ = paddesize(size(f));</code></p>
</li>
<li><p>得到使用填充的傅里叶变换</p>
<p><code>F = fft2(f, PQ(1), PQ(2));</code></p>
</li>
<li><p>使用本章讨论的任意一个方法，生成一个大小为$PQ(1)\times PQ(2)$的滤波函数$H$。该滤波函数的格式必须如下图b所示。另外，如果它若图a所示，则在使用该滤波器前，需要令<code>H = fftshift(H);</code></p>
<p><img src="21.png" style="zoom:50%;"></p>
</li>
<li><p>将变换乘以滤波函数</p>
<p><code>G = H.*F;</code></p>
</li>
<li><p>获得G的傅里叶逆变换实部</p>
<p><code>g = real(ifft(G));</code></p>
</li>
<li><p>将左上部的矩形修建为原始尺寸大小</p>
<p><code>g = g( 1:size(f, 1), 1:size(f, 2) );</code></p>
</li>
</ol>
<p><strong>步骤567可以用以下的函数dftfilt()代替</strong></p>
<p>一个用于频域滤波的M函数，输入一个图像和滤波函数，输出经滤波和剪切后的图像</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">g</span> = <span class="title">dftfilt</span><span class="params">(f, H, classout)</span></span></span><br><span class="line"><span class="comment">%DFTFILT Performs frequency domain filtering.</span></span><br><span class="line"><span class="comment">%   g = DFTFILT(f, H, CLASSOUT) filters f in the frequency domain</span></span><br><span class="line"><span class="comment">%   using the filter transfer function H. The output, g, is the</span></span><br><span class="line"><span class="comment">%   filtered image, which has the same size as f. </span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">%   Valid values of CLASSOUT are</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">%	'original'	The ouput is of the same class as the input. </span></span><br><span class="line"><span class="comment">%               This is the default if CLASSOUT is not included</span></span><br><span class="line"><span class="comment">%               in the call.</span></span><br><span class="line"><span class="comment">%	'fltpoint'	The output is floating point of class single, unless</span></span><br><span class="line"><span class="comment">%               both f and H are of class double, in which case the</span></span><br><span class="line"><span class="comment">%               output also is of class double.</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">%   DFTFILT automatically pads f to be the same size as H. Both f</span></span><br><span class="line"><span class="comment">%   and H must be real. In addition, H must be an uncentered,</span></span><br><span class="line"><span class="comment">%   circularly-symmetric filter function.  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">%   Copyright 2002-2009 R. C. Gonzalez, R. E. Woods, and S. L. Eddins</span></span><br><span class="line"><span class="comment">%   From the book Digital Image Processing Using MATLAB, 2nd ed.,</span></span><br><span class="line"><span class="comment">%   Gatesmark Publishing, 2009.</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">%   Book web site: http://www.imageprocessingplace.com</span></span><br><span class="line"><span class="comment">%   Publisher web site: http://www.gatesmark.com/DIPUM2e.htm</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% Convert the input to floating point.</span></span><br><span class="line">[f, revertClass] = tofloat(f);</span><br><span class="line"></span><br><span class="line"><span class="comment">% Obtain the FFT of the padded input.</span></span><br><span class="line">F = fft2(f, <span class="built_in">size</span>(H, <span class="number">1</span>), <span class="built_in">size</span>(H, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">% Perform filtering. </span></span><br><span class="line">g = ifft2(H.*F);</span><br><span class="line"></span><br><span class="line"><span class="comment">% Crop to original size.</span></span><br><span class="line">g = g(<span class="number">1</span>:<span class="built_in">size</span>(f, <span class="number">1</span>), <span class="number">1</span>:<span class="built_in">size</span>(f, <span class="number">2</span>)); <span class="comment">% g is of class single here.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% Convert the output to the same class as the input if so specified.</span></span><br><span class="line"><span class="keyword">if</span> nargin == <span class="number">2</span> || strcmp(classout, <span class="string">'original'</span>)</span><br><span class="line">   g = revertClass(g);</span><br><span class="line"><span class="keyword">elseif</span> strcmp(classout, <span class="string">'fltpoint'</span>) <span class="comment">% g is floating point already.</span></span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   error(<span class="string">'Undefined class for the output image.'</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>滤波器较小时，空间滤波较频域滤波更有效。而较大时，使用FFT的滤波比空间卷积则要快。</p>
<p>如何将空间滤波器转换成频域滤波器，详情见Matlab版教材P89。</p>
<p>使用dftuv函数计算每一点到矩阵原点的距离</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[U, V]</span> = <span class="title">dftuv</span><span class="params">(M, N)</span></span></span><br><span class="line"><span class="comment">%DFTUV Computes meshgrid frequency matrices.</span></span><br><span class="line"><span class="comment">%   [U, V] = DFTUV(M, N) computes meshgrid frequency matrices U and</span></span><br><span class="line"><span class="comment">%   V.  U and V are useful for computing frequency-domain filter</span></span><br><span class="line"><span class="comment">%   functions that can be used with DFTFILT.  U and V are both</span></span><br><span class="line"><span class="comment">%   M-by-N and of class single.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%   Copyright 2002-2009 R. C. Gonzalez, R. E. Woods, and S. L. Eddins</span></span><br><span class="line"><span class="comment">%   From the book Digital Image Processing Using MATLAB, 2nd ed.,</span></span><br><span class="line"><span class="comment">%   Gatesmark Publishing, 2009.</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">%   Book web site: http://www.imageprocessingplace.com</span></span><br><span class="line"><span class="comment">%   Publisher web site: http://www.gatesmark.com/DIPUM2e.htm</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% Set up range of variables.</span></span><br><span class="line">u = single(<span class="number">0</span>:(M - <span class="number">1</span>));</span><br><span class="line">v = single(<span class="number">0</span>:(N - <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">% Compute the indices for use in meshgrid.</span></span><br><span class="line">idx = <span class="built_in">find</span>(u &gt; M/<span class="number">2</span>);</span><br><span class="line">u(idx) = u(idx) - M;</span><br><span class="line">idy = <span class="built_in">find</span>(v &gt; N/<span class="number">2</span>);</span><br><span class="line">v(idy) = v(idy) - N;</span><br><span class="line"></span><br><span class="line"><span class="comment">% Compute the meshgrid arrays. </span></span><br><span class="line">[V, U] = <span class="built_in">meshgrid</span>(v, u);</span><br><span class="line"></span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">%使用dftuv，计算一个8*5大小矩阵每点距原点距离</span></span><br><span class="line">[U,V] = dftuv(<span class="number">8</span>, <span class="number">5</span>);</span><br><span class="line">D = U.^<span class="number">2</span> + V.^<span class="number">2</span>;</span><br><span class="line">D =</span><br><span class="line"></span><br><span class="line">  <span class="number">8</span>×<span class="number">5</span> single 矩阵</span><br><span class="line"></span><br><span class="line">     <span class="number">0</span>     <span class="number">1</span>     <span class="number">4</span>     <span class="number">4</span>     <span class="number">1</span></span><br><span class="line">     <span class="number">1</span>     <span class="number">2</span>     <span class="number">5</span>     <span class="number">5</span>     <span class="number">2</span></span><br><span class="line">     <span class="number">4</span>     <span class="number">5</span>     <span class="number">8</span>     <span class="number">8</span>     <span class="number">5</span></span><br><span class="line">     <span class="number">9</span>    <span class="number">10</span>    <span class="number">13</span>    <span class="number">13</span>    <span class="number">10</span></span><br><span class="line">    <span class="number">16</span>    <span class="number">17</span>    <span class="number">20</span>    <span class="number">20</span>    <span class="number">17</span></span><br><span class="line">     <span class="number">9</span>    <span class="number">10</span>    <span class="number">13</span>    <span class="number">13</span>    <span class="number">10</span></span><br><span class="line">     <span class="number">4</span>     <span class="number">5</span>     <span class="number">8</span>     <span class="number">8</span>     <span class="number">5</span></span><br><span class="line">     <span class="number">1</span>     <span class="number">2</span>     <span class="number">5</span>     <span class="number">5</span>     <span class="number">2</span></span><br><span class="line">fftshift(D);<span class="comment">%中心化</span></span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"></span><br><span class="line">  <span class="number">8</span>×<span class="number">5</span> single 矩阵</span><br><span class="line"></span><br><span class="line">    <span class="number">20</span>    <span class="number">17</span>    <span class="number">16</span>    <span class="number">17</span>    <span class="number">20</span></span><br><span class="line">    <span class="number">13</span>    <span class="number">10</span>     <span class="number">9</span>    <span class="number">10</span>    <span class="number">13</span></span><br><span class="line">     <span class="number">8</span>     <span class="number">5</span>     <span class="number">4</span>     <span class="number">5</span>     <span class="number">8</span></span><br><span class="line">     <span class="number">5</span>     <span class="number">2</span>     <span class="number">1</span>     <span class="number">2</span>     <span class="number">5</span></span><br><span class="line">     <span class="number">4</span>     <span class="number">1</span>     <span class="number">0</span>     <span class="number">1</span>     <span class="number">4</span></span><br><span class="line">     <span class="number">5</span>     <span class="number">2</span>     <span class="number">1</span>     <span class="number">2</span>     <span class="number">5</span></span><br><span class="line">     <span class="number">8</span>     <span class="number">5</span>     <span class="number">4</span>     <span class="number">5</span>     <span class="number">8</span></span><br><span class="line">    <span class="number">13</span>    <span class="number">10</span>     <span class="number">9</span>    <span class="number">10</span>    <span class="number">13</span></span><br></pre></td></tr></table></figure>
<p>下面介绍可以传入dftfilt函数的所有滤波函数的封装：</p>
<h4 id="平滑滤波器-低通滤波器lpfilter"><a href="#平滑滤波器-低通滤波器lpfilter" class="headerlink" title="平滑滤波器/低通滤波器lpfilter"></a>平滑滤波器/低通滤波器lpfilter</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">H</span> = <span class="title">lpfilter</span><span class="params">(type, M, N, D0, n)</span></span></span><br><span class="line"><span class="comment">%LPFILTER Computes frequency domain lowpass filters.</span></span><br><span class="line"><span class="comment">%   H = LPFILTER(TYPE, M, N, D0, n) creates the transfer function of</span></span><br><span class="line"><span class="comment">%   a lowpass filter, H, of the specified TYPE and size (M-by-N). To</span></span><br><span class="line"><span class="comment">%   view the filter as an image or mesh plot, it should be centered</span></span><br><span class="line"><span class="comment">%   using H = fftshift(H). </span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">%   Valid values for TYPE, D0, and n are:</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">%   'ideal'    Ideal lowpass filter with cutoff frequency D0. n need</span></span><br><span class="line"><span class="comment">%              not be supplied.  D0 must be positive.</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">%   'btw'      Butterworth lowpass filter of order n, and cutoff</span></span><br><span class="line"><span class="comment">%              D0.  The default value for n is 1.0.  D0 must be</span></span><br><span class="line"><span class="comment">%              positive.</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">%   'gaussian' Gaussian lowpass filter with cutoff (standard</span></span><br><span class="line"><span class="comment">%              deviation) D0.  n need not be supplied.  D0 must be</span></span><br><span class="line"><span class="comment">%              positive.</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">%  H is of floating point class single. It is returned uncentered</span></span><br><span class="line"><span class="comment">%  for consistency with filtering function dftfilt. To view H as an</span></span><br><span class="line"><span class="comment">%  image or mesh plot, it should be centered using Hc = fftshift(H).</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%   Copyright 2002-2009 R. C. Gonzalez, R. E. Woods, and S. L. Eddins</span></span><br><span class="line"><span class="comment">%   From the book Digital Image Processing Using MATLAB, 2nd ed.,</span></span><br><span class="line"><span class="comment">%   Gatesmark Publishing, 2009.</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">%   Book web site: http://www.imageprocessingplace.com</span></span><br><span class="line"><span class="comment">%   Publisher web site: http://www.gatesmark.com/DIPUM2e.htm</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% Use function dftuv to set up the meshgrid arrays needed for</span></span><br><span class="line"><span class="comment">% computing the required distances. </span></span><br><span class="line">[U, V] = dftuv(M, N);</span><br><span class="line"></span><br><span class="line"><span class="comment">% Compute the distances D(U, V).</span></span><br><span class="line">D = <span class="built_in">hypot</span>(U, V);</span><br><span class="line"></span><br><span class="line"><span class="comment">% Begin filter computations.</span></span><br><span class="line"><span class="keyword">switch</span> <span class="built_in">type</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">'ideal'</span></span><br><span class="line">   H = single(D &lt;= D0);</span><br><span class="line"><span class="keyword">case</span> <span class="string">'btw'</span></span><br><span class="line">   <span class="keyword">if</span> nargin == <span class="number">4</span></span><br><span class="line">      n = <span class="number">1</span>;	</span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line">   H = <span class="number">1.</span>/(<span class="number">1</span> + (D./D0).^(<span class="number">2</span>*n));</span><br><span class="line"><span class="keyword">case</span> <span class="string">'gaussian'</span></span><br><span class="line">   H = <span class="built_in">exp</span>(-(D.^<span class="number">2</span>)./(<span class="number">2</span>*(D0^<span class="number">2</span>)));</span><br><span class="line"><span class="keyword">otherwise</span></span><br><span class="line">   error(<span class="string">'Unknown filter type.'</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>可视化滤波器函数</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%直接用mesh()函数即可</span></span><br><span class="line">mesh(H);</span><br><span class="line"><span class="comment">%若是M和N很大，则可以用一下形式</span></span><br><span class="line">mesh( H( <span class="number">1</span>:k:<span class="keyword">end</span> , <span class="number">1</span>:k:<span class="keyword">end</span> ) );</span><br><span class="line"></span><br><span class="line"><span class="comment">%其实四种绘制三维图的方式都可以</span></span><br><span class="line"><span class="comment">%surf(),mesh().contour3()(在此处效果不合适),waterfall()</span></span><br></pre></td></tr></table></figure>
<h4 id="锐化滤波器-高通滤波器hpfilter"><a href="#锐化滤波器-高通滤波器hpfilter" class="headerlink" title="锐化滤波器/高通滤波器hpfilter"></a>锐化滤波器/高通滤波器hpfilter</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">H</span> = <span class="title">hpfilter</span><span class="params">(type, M, N, D0, n)</span></span></span><br><span class="line"><span class="comment">%HPFILTER Computes frequency domain highpass filters.</span></span><br><span class="line"><span class="comment">%   H = HPFILTER(TYPE, M, N, D0, n) creates the transfer function of</span></span><br><span class="line"><span class="comment">%   a highpass filter, H, of the specified TYPE and size (M-by-N).</span></span><br><span class="line"><span class="comment">%   </span></span><br><span class="line"><span class="comment">%   Valid values for TYPE, D0, and n are: </span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">%   'ideal'    Ideal highpass filter with cutoff frequency D0.  n</span></span><br><span class="line"><span class="comment">%              need not be supplied. D0 must be positive.</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">%   'btw'      Butterworth highpass filter of order n, and cutoff</span></span><br><span class="line"><span class="comment">%              D0.  The default value for n is 1.0. D0 must be</span></span><br><span class="line"><span class="comment">%              positive.</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">%   'gaussian' Gaussian highpass filter with cutoff (standard</span></span><br><span class="line"><span class="comment">%              deviation) D0. n need not be supplied. D0 must be</span></span><br><span class="line"><span class="comment">%              positive.</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">%  H is of floating point class single. It is returned uncentered</span></span><br><span class="line"><span class="comment">%  for consistency with filtering function dftfilt. To view H as an</span></span><br><span class="line"><span class="comment">%  image or mesh plot, it should be centered using Hc = fftshift(H).</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%   Copyright 2002-2009 R. C. Gonzalez, R. E. Woods, and S. L. Eddins</span></span><br><span class="line"><span class="comment">%   From the book Digital Image Processing Using MATLAB, 2nd ed.,</span></span><br><span class="line"><span class="comment">%   Gatesmark Publishing, 2009.</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">%   Book web site: http://www.imageprocessingplace.com</span></span><br><span class="line"><span class="comment">%   Publisher web site: http://www.gatesmark.com/DIPUM2e.htm</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% The transfer function Hhp of a highpass filter is 1 - Hlp, </span></span><br><span class="line"><span class="comment">% where Hlp is the transfer function of the corresponding lowpass </span></span><br><span class="line"><span class="comment">% filter.  Thus, we can use function lpfilter to generate highpass </span></span><br><span class="line"><span class="comment">% filters.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> nargin == <span class="number">4</span></span><br><span class="line">   n = <span class="number">1</span>; <span class="comment">% Default value of n.</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% Generate highpass filter.</span></span><br><span class="line">Hlp = lpfilter(<span class="built_in">type</span>, M, N, D0, n);</span><br><span class="line">H = <span class="number">1</span> - Hlp;</span><br></pre></td></tr></table></figure>
<h4 id="高频增强滤波器"><a href="#高频增强滤波器" class="headerlink" title="高频增强滤波器"></a>高频增强滤波器</h4><script type="math/tex; mode=display">
H_{hfe}(u,v)=a+bH_{hp}(u,v)</script><p>a是偏移量，b是乘数，$H_{hp}(u,v)$是高通滤波器的传递函数；</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PO = paddedsize(<span class="built_in">size</span>(f));</span><br><span class="line">DO=<span class="number">0.05</span>*PQ(<span class="number">1</span>);</span><br><span class="line">HBW = hpfilter(<span class="string">'btw'</span>, PQ(<span class="number">1</span>), PQ(<span class="number">2</span>), DO, <span class="number">2</span>);</span><br><span class="line">H = <span class="number">0.5</span> + <span class="number">2</span>*HBW;</span><br><span class="line">gbw = dftfilt(f, HBW, <span class="string">'fltpoint'</span>); </span><br><span class="line">gbw = gscale(gbw);</span><br><span class="line">ghf = dftfilt(fl H, <span class="string">'fltpoint'</span>);</span><br><span class="line">ghf = gscale (ghf );</span><br><span class="line">ghe = histeq(ghf, <span class="number">256</span>);</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://dongxh.cn/2020/03/19/频域的图像增强/" data-id="ck8l56qn40013tmlkezicxh09" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数字图像处理/">数字图像处理</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-空间域的图像增强" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/17/空间域的图像增强/" class="article-date">
  <time datetime="2020-03-17T13:32:33.000Z" itemprop="datePublished">2020-03-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Digital-Image-Process/">Digital Image Process</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/17/空间域的图像增强/">空间域的图像增强</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="空间域的图像增强"><a href="#空间域的图像增强" class="headerlink" title="空间域的图像增强"></a>空间域的图像增强</h1><h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><ol>
<li><p>什么是图像增强？</p>
<p>图像增强是要突出图像中的某些信息，同时削弱或去除某些不需要信息的一种处理方法，以得到对具体应用 来说视觉效果更“好”，或更“有用”的图像的技术。</p>
</li>
<li><p>为什么要图像增强？</p>
<p>图像在传输或者处理过程中会引入噪声或使图像变模糊，从而降低了图像质量，甚至淹没了特征，给分析带来 了困难。</p>
</li>
<li><p>图像增强的目的：</p>
<p>(1)改善图像的视觉效果，提高图像的清晰度;</p>
<p>(2)将图像转换成更适合于人眼观察和机器分析识别的形式，以便从图像中获取更有用的信息。</p>
</li>
<li><p>基本方法</p>
<p><img src="1.png" style="zoom: 33%;">、</p>
</li>
</ol>
<h3 id="基本灰度变换"><a href="#基本灰度变换" class="headerlink" title="基本灰度变换"></a>基本灰度变换</h3><ol>
<li><p>对数变换</p>
<p>$s = c\ log(1+r)$，$c$为常数，</p>
<p><strong>作用</strong>：用来扩展被压缩的高值图像中的暗像素。</p>
<p><strong>缺点</strong>：很大程度上压缩了图像像素的动态范围。</p>
<p>一般应用：压缩傅立叶变换的动态范围等。</p>
</li>
<li><p>幂次变换</p>
<p>$s=c\ r^{\gamma}$，$c$为常数。</p>
<p><strong>作用</strong>：$\gamma<1$时，把低亮度进行拉伸（因为原图片需要的细节大多在暗处，需要仔细分辨）；$\gamma>1$时，把高亮度进行拉伸（因为原图片需要的细节大多在亮处，需要把亮处拉长范围观察）；</1$时，把低亮度进行拉伸（因为原图片需要的细节大多在暗处，需要仔细分辨）；$\gamma></p>
<p><img src="2.png" style="zoom: 33%;"></p>
<p><strong>伽马校正</strong>：几乎所有的CRT显示设备、摄像胶片、许多电子照相机的 光电转换特性都是非线                                                   性的。所以，如果不进行校正处理的话 ，将无法得到好的图像效果。</p>
</li>
<li><p>图像反转</p>
<p>$s=L-1-r$，$L$为亮度级（灰度级）</p>
<p><strong>作用</strong>：适于处理增强嵌入于图像暗色区域的白色或灰色细节,特别是当黑色面积占主导地位时。</p>
</li>
<li><p>分段线性变换</p>
<p>其形式可以任意组合，有些重要的变换可以应 用分段线性函数描述。</p>
<p>（1）对比拉伸：扩展图像处理时某范围灰度级的动态范围<img src="3.png" style="zoom: 25%;">，如图，可以选择性的拉伸$[r_1,r_2]$范围的动态范围到$[s_1,s_2]$范围</p>
<p>（2）突出图像中特定灰度范围的<strong>亮度</strong>，可以增强某些特征；</p>
<p>突出目标轮廓，<strong>消除</strong>背景细节：<img src="4.png" style="zoom: 25%;"></p>
<p>突出目标轮廓，<strong>保留</strong>背景细节：<img src="5.png" style="zoom:25%;"></p>
<p>（3）<strong>比特平面分割</strong>:把数字图像分解成为<strong>位平面</strong>，高阶位如前4位包含视觉上很重要的大多数数据;其它位对图像中 的更多微小细节有作用。</p>
<p><img src="6.png" style="zoom: 33%;"></p>
</li>
</ol>
<p>   该图为比特面分层的实例：</p>
<p>   <img src="7.png" style="zoom:50%;"></p>
<h3 id="直方图处理"><a href="#直方图处理" class="headerlink" title="直方图处理"></a>直方图处理</h3><p><strong>灰度直方图</strong>：灰度级的函数，描述的是图像中具有该灰度级的像素的个数。</p>
<p>​        横轴表示灰度级，纵轴表示每一灰度级具有的像素数或该像素数占总像素数的比例值，做出的条形统计图即为灰度直方图。</p>
<p><strong>直方图意义</strong>：</p>
<ul>
<li><p>反应图像的灰度分布情况</p>
<ul>
<li>低端分布的直方图，图象较暗</li>
<li>高端分布的直方图，图象太亮</li>
<li>直方图分布狭窄，图象对比度不够</li>
<li>直方图的多个峰值，一般对应多类目标</li>
</ul>
</li>
<li><p>指出图象增强处理的方向</p>
<ul>
<li><p>直方图的均衡化</p>
<p>均匀分布的直方图，扩大动态范围，增大图象对比度</p>
</li>
<li><p>直方图的规定化</p>
<p>符合特定分布的直方图，有目的地增强感兴趣目标</p>
</li>
</ul>
</li>
</ul>
<p>应用于图像增强技术，图像压缩及分割。</p>
<p>一般会对直方图进行归一化操作。</p>
<p><strong>直方图均衡化</strong>：</p>
<p>中心思想：是把原始图像的灰度直方图从比较集中的某个灰度区 间变成在全部灰度范围内的均匀分布。是对图像的非线性拉伸。</p>
<p>• 变换原始图像的直方图为均匀分布</p>
<p>​           ==&gt; 增大动态范围<br> • 使像素灰度值的动态范围最大</p>
<p>​           ==&gt; 增强图像整体对比度(反差)</p>
<ul>
<li><strong>优点</strong>：对于背景和前景都太亮或者太暗的图像非常有用；如X光图像的骨骼结构显示、以及曝光过度或者曝光不足照片中更好的细节。</li>
<li><strong>缺点</strong>：对处理的数据不加选择，可能会降低有用信号的对比度; 变换后图像的灰度级减少，某些细节消失; 某些图像，如直方图有高峰，经处理后对比度不自然的过分增强。</li>
</ul>
<p><strong>直方图规定化</strong>：</p>
<p>目的：将原始图象的直方图转换为期望的直方图的形状</p>
<p>算法思想:</p>
<p>– 设:$\{r_k\}$是原图象的灰度级,<br>         • $\{z_k\}$是符合指定直方图结果图象的灰度级</p>
<p>– 目标:找到一个灰度级变换函数$T$,使: </p>
<p>  (1)$z_k=T(r_k)$     $r\to z$ </p>
<p>​         (2)从概率密度函数(直方图)入手</p>
<p><strong>直方图规定化vs. 直方图均衡化</strong></p>
<ul>
<li><p>直方图均衡化: 自动增强</p>
<p>• 效果不易控制</p>
<p>• 总得到全图增强的结果</p>
</li>
<li><p>直方图规定化: 有选择地增强</p>
<p>• 须给定需要的直方图 </p>
<p>• 可特定增强的结果</p>
</li>
</ul>
<h3 id="空间滤波基础"><a href="#空间滤波基础" class="headerlink" title="空间滤波基础"></a>空间滤波基础</h3><p>空间滤波器的通用实现方法———邻域加权运算（掩模运算）</p>
<p>空间滤波计算公式（掩模计算公式）：</p>
<script type="math/tex; mode=display">
g(x)=\sum_{s=-a}^{a}w(s)f(x+s)</script><p><img src="8.png" style="zoom: 40%;"></p>
<p>在空间借助模版进行滤波操作有两个分类标准：</p>
<ul>
<li>线性/非线性</li>
<li>平滑/锐化</li>
</ul>
<h3 id="平滑滤波器"><a href="#平滑滤波器" class="headerlink" title="平滑滤波器"></a>平滑滤波器</h3><p>原理：</p>
<ul>
<li>减弱或消除高频分量，保留低频分量</li>
<li>平滑处理往往用于图像分割之前，因为它可以去除噪声也可以填补图像边缘中的间隙，有利于从图像中找出目标。</li>
</ul>
<p>算法设计：</p>
<ul>
<li>平滑的主要目标是去除噪声</li>
<li>平滑的附加要求是保护图像信息的细节</li>
</ul>
<p><strong>均值滤波器</strong>：<img src="9.png" style="zoom: 33%;">  <strong>加权均值滤波器</strong>：<img src="10.png" style="zoom:33%;"> </p>
<p>模板尺寸越大，图像越模糊，图像细节丢失越多。</p>
<p>平滑处理的应用:在提取大目标前，去除图像中一些琐碎的细节，“有所失才能 有所得”。</p>
<p><strong>高斯滤波器(Gaussian Filters)</strong>:</p>
<p>– 采用高斯函数作为加权函数。$G(x,y)=e^{-\frac{x^2+y^2}{2\sigma^2}}=e^{-\frac{r^2}{2\sigma^2}}$ </p>
<p>– 原因一:二维高斯函数具有旋转对称性，保证滤波时各方向平滑 程度相同;</p>
<p>– 原因二:离中心点越远权值越小。确保边缘细节不被模糊。</p>
<p>设计高斯滤波器的方法：</p>
<ol>
<li>设定$\sigma^2$和$n$的值</li>
<li>整数画和归一化</li>
</ol>
<p><strong>平滑滤波的边缘保持</strong>：</p>
<ul>
<li><p>带门限的邻域平均：</p>
<p>思想：有噪声就进行滤波平均，没有噪声则不进行处理</p>
</li>
</ul>
<script type="math/tex; mode=display">
g(m,n)=\left\{\begin{matrix}
\frac{1}{N}\sum_{(i,j)\in S}f(i,j),&\left | f(m,n)-\frac{1}{N}\sum_{(i,j)\in S}f(i,j) \right | >T\\ 
 f(m,n),& other
\end{matrix}\right.</script><ul>
<li><p>半邻域平均</p>
<p>思想：判断邻域中有无边缘，没有边缘，可以不担心细节信息被平滑，被处理像素灰度采用全邻域均值；否则，根据邻域中的目 标信息为被处理像素赋值。</p>
<p>如何判断边缘是否存在（<strong>边缘检测</strong>）：</p>
<p>​    –邻域中8个邻点像素分为2组，灰度值小的3个A组，其他B组 </p>
<p>​    –两组之间灰度差别大，认为有边缘，否则无边缘</p>
<p>算法：</p>
<p>​    –对P点的邻点$A_i$灰度排序，分为A、B两组 <img src="12.png" style="zoom:35%;"></p>
<p>​    –计算A组均值$M_3$，B组加P点均值$M_6$和全邻域均值$N$</p>
<p>​    –根据预设门限$T$，被处理像素的新灰度为$g(m,n)=\left\{\begin{matrix}<br>N,&amp;\left |M_6-M_3\right | \leqslant T\\<br> M_6,&amp; \left |M_6-M_3\right | &gt; T<br>\end{matrix}\right.$  </p>
</li>
</ul>
<p><strong>统计排序滤波器</strong>：</p>
<p>​        非线性空间滤波器，其响应是基于图像滤波器所包围区域中像素(灰度)的排序，用排序结果的值代替中心像素的值。</p>
<p>​        常见的如<strong>中值滤波器</strong>，该滤波器对脉冲噪声特有效。</p>
<h3 id="锐化滤波器"><a href="#锐化滤波器" class="headerlink" title="锐化滤波器"></a>锐化滤波器</h3><p>原理：</p>
<ul>
<li>减弱或消除低频分量，保留高频分量， 又称高通滤波器</li>
</ul>
<p>目的：</p>
<ul>
<li>突出图像中细节或被模糊的细节(灰度过渡部分)， 锐化可用微分来完成，而微分算子的响应强度与图像在该点的突变程度有关。</li>
</ul>
<p>一阶微分滤波器：Roberts梯度算子，Sobel梯度算子，Prewitt梯度算子等；</p>
<p>拉普拉斯微分算子，二阶微分滤波器：<img src="13.png" style="zoom:33%;"></p>
<p>实现方式：最终图像=通过掩模处理的图像+原图像</p>
<p>掩模在中心处加1，等于最终模版；</p>
<h2 id="Matlab实现"><a href="#Matlab实现" class="headerlink" title="Matlab实现"></a>Matlab实现</h2><h3 id="灰度转换"><a href="#灰度转换" class="headerlink" title="灰度转换"></a>灰度转换</h3><p>Spatial Filtering————————-空间滤波（neighborhood processing or spatial convolution，领域处理或空间卷积）</p>
<p>fuzzy image processing———模糊图像处理</p>
<p>g(x,y)= T[f(x,y)]，f为输入，g为输出</p>
<p>T是在关于点（x，y）的<strong>指定邻域</strong>上定义的f上的算子。</p>
<p><strong>Intensity Transformation Functions灰度转换方程</strong></p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">g = imadjust(f, [low_in high_in] , [low_out high_out] , <span class="built_in">gamma</span>);<span class="comment">%幂律（伽马）变换  Using the empty matrix ( [ J ) for [ low_in high_in ] or for [ low_out high_out ] results in the default values [ 0 1 ] . If high_out is less than low_out, the output intensity is reversed.</span></span><br><span class="line"></span><br><span class="line">g = imcomplement(f);<span class="comment">%This MATLAB function computes the complement of the image I and returns the result in J.补数，负片</span></span><br><span class="line"></span><br><span class="line">Low_High = stretchlim(f);<span class="comment">%strechlim，找到对比度拉伸图像的极限，目的是增强对比度</span></span><br><span class="line"><span class="comment">%%一般用法%%</span></span><br><span class="line">g = imadjust(f, stretchlim(f), [ ]);</span><br><span class="line"></span><br><span class="line">Low_High = stretchlim(f, tol)<span class="comment">%tol 是饱和度，可以是一个向量 [low_frac high_frac]，也可以是一个标量，low_frac = tol, and high_frac = 1 - low_frac；tol defaults to [0.01 0.99]；</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%%%对数变换和对比度拉伸%%%</span></span><br><span class="line"><span class="comment">%Logarithmic and Contrast-Stretching Transformations%</span></span><br><span class="line">g = c*<span class="built_in">log</span>(<span class="number">1</span> + f);<span class="comment">%对数变换</span></span><br><span class="line"></span><br><span class="line">gs = im2uint8(mat2gray(g) );<span class="comment">%Using mat2gray brings the values to the range [O, 1] and using im2uint8 brings them to the range [O, 255], converting the image to class uint8.</span></span><br></pre></td></tr></table></figure>
<p>contrast-stretching transformation function对比度拉伸方程</p>
<p><img src="14.png" style="zoom: 50%;"><img src="15.png" style="zoom: 50%;"></p>
<p>E控制斜率，<code>g = 1./(1 + (m./f).^E)</code></p>
<p>thresholding function阈值方程（对于图像分割很方便）</p>
<p><img src="16.png" style="zoom: 50%;"></p>
<p><strong>Specifying Arbitrary Intensity Transformations指定任意强度转换</strong></p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">linspace</span>(x1,x2,N);<span class="comment">%从x1开始，x2结束，中间线性插值N个点，返回插值数组（行向量）</span></span><br><span class="line"><span class="built_in">numel</span>(A);<span class="comment">%返回元素个数</span></span><br><span class="line"></span><br><span class="line">yi= interp1(x,y,xi,<span class="string">'method'</span>);<span class="comment">%其中x，y为插值点，yi为在被插值点xi处的插值结果；x,y为向量,'method'表示采用的插值方法，MATLAB提供的插值方法有几种： 'nearest'是最邻近插值， 'linear'线性插值； 'spline'三次样条插值； 'pchip'立方插值．缺省时表示线性插值</span></span><br><span class="line"></span><br><span class="line">g = interp1(z, T, f);<span class="comment">%f是输入图像, g是输出头像, T灰度级的列向量, z和T是长度一样的列向量</span></span><br><span class="line">z = <span class="built_in">linspace</span>(O, <span class="number">1</span>, <span class="built_in">numel</span>(T))‘;<span class="comment">%意思为在0到1范围内线性插值255个</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">%任意强度变换的关键在于任意变换函数T（r）</span></span><br><span class="line"><span class="comment">%T（r）可以取任意离散值来映射，z是原像，T(r)是像，线性按顺序映射</span></span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%</span></span><br></pre></td></tr></table></figure>
<p><strong>一些对于灰度转换有用方程</strong></p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = nargin;</span><br><span class="line">b = nargout;<span class="comment">%输入输出的参数个数</span></span><br></pre></td></tr></table></figure>
<p><strong>Histogram Processing and Function Plotting</strong></p>
<p><img src="17.png" alt="image-20200312211016391" style="zoom: 67%;"></p>
<p>r~k~是第k级灰度值，n~k~是图像中灰度为r~k~的像素的个数。</p>
<p>通常用乘积MN表示图像像素的个数，M和N分别表示图像的行和列的维数。</p>
<p>归一化后的直方图由<img src="18.png" alt="image-20200312211749614" style="zoom: 67%;"></p>
<p>　</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">h = imhist(f, b);<span class="comment">%b表示讲直方图分成b个部分,b默认256</span></span><br><span class="line">p = imhist(f, b)/<span class="built_in">numel</span>(f);</span><br></pre></td></tr></table></figure>
<p><strong>Histogram Equalization直方图均衡化</strong></p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">g = histeq(f, nlev);<span class="comment">%nlev为输出图像指定的灰度级数，函数中nlev默认为64</span></span><br><span class="line"></span><br><span class="line">cdf = cumsum(A);<span class="comment">%累加和</span></span><br></pre></td></tr></table></figure>
<p><strong>直方图匹配（规定化）</strong></p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g = histeq(f, hspec);<span class="comment">%hspec为指定的直方图（一个由指定值构成的行向量）</span></span><br></pre></td></tr></table></figure>
<h3 id="空间滤波"><a href="#空间滤波" class="headerlink" title="空间滤波"></a>空间滤波</h3><p>工具箱使用imfilter函数来实现<strong>线性空间滤波</strong>：</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">%  f为输入图像， w为滤波掩模， g为滤波结果</span></span><br><span class="line"><span class="comment">%  filtering_mode用于指定滤波过程中使用的是相关（'corr'）还是卷积（'conv'）</span></span><br><span class="line"><span class="comment">%  boundary_optiony用于处理边界充零问题，边界的大小由滤波器掩模决定</span></span><br><span class="line"><span class="comment">%  size_option可以是same，或者是full</span></span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line">g = imfilter(f, w, filtering_mode, boundary_options, size_option);</span><br><span class="line"><span class="comment">%imfilter会讲输出图像转化为输入图像相同的类</span></span><br></pre></td></tr></table></figure>
<p><img src="19.png" style="zoom:60%;"></p>
<p><strong>非线性滤波器</strong></p>
<p>在非线性滤波处理中，掩模的概念并不流行。滤波器应该看作是一个基于领域像素操作的非线性函数，其函数结果组成了领域中心像素处操作的响应。</p>
<p>工具箱提供两个执行常规非线性滤波的函数nlfilter和函数colfilter.</p>
<p>nlflter函数直接执行二维操作；</p>
<p>colfilter函数以列的形式组织数据；内存占用多，但是速度快，所以<strong>常用这个函数</strong>。</p>
<p>colfilter函数的计算过程：</p>
<p><img src="20.png" style="zoom:60%;"></p>
<p>$\ast \ \ A$总共有mn行，但列数可根据输入的尺寸变化，尺寸的选择由colfilter自动完成。</p>
<p>语法：</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">%		m,n为滤波区域的维数</span></span><br><span class="line"><span class="comment">%		'sliding'表示处理过程是在输入图像f中中逐个像素地滑动该m*n区域</span></span><br><span class="line"><span class="comment">%		@fun表示这里需要一个函数，fun必须对矩阵A的每一列操作，并返回一个包含所有列向量结果的行向量</span></span><br><span class="line"><span class="comment">%		parameters表示fun可能需要的参数，用逗号隔开</span></span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line">g = colfilter(f, [m n], <span class="string">'sliding'</span>, @fun, parameters);</span><br></pre></td></tr></table></figure>
<p>在使用colfilter滤波前，需要对图像进行填充，使用padarray函数进行填充</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">%		[r c]用于给出填充f的行数和列数</span></span><br><span class="line"><span class="comment">%		</span></span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line">fp = padarray(f, [r c], method, direction);</span><br></pre></td></tr></table></figure>
<p><img src="21.png" style="zoom:60%;"></p>
<p>生成滤波掩模w的函数fspecial为：</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w = fspecial( <span class="string">'type'</span> , parameters)；<span class="comment">%针对线性空间滤波器</span></span><br></pre></td></tr></table></figure>
<p><img src="22.png" style="zoom:50%;"></p>
<p><strong>统计排序滤波器</strong></p>
<p>函数ordfilt2</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%使用邻域的一组排序元素中的第order个元素来代替f中的每一个元素，而该邻域是由domain中非零元素指定的</span></span><br><span class="line">g = ordfilt2(f, order, domain);</span><br><span class="line"></span><br><span class="line"><span class="comment">%中值滤波器</span></span><br><span class="line"><span class="comment">%padpot表示填充方式，zeros(默认),symmetric,indexed.</span></span><br><span class="line">g = medfilt2(f, [m n] , padopt)；</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://dongxh.cn/2020/03/17/空间域的图像增强/" data-id="ck8l56qjn000vtmlkbuf54ter" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数字图像处理/">数字图像处理</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Digital-Image-Process/">Digital Image Process</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Operating-System/">Operating System</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/life-record/">life record</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/linear-algebra/">linear algebra</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/life-record/">life record</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linear-algebra/">linear algebra</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/操作系统/">操作系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数字图像处理/">数字图像处理</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/life-record/" style="font-size: 10px;">life record</a> <a href="/tags/linear-algebra/" style="font-size: 10px;">linear algebra</a> <a href="/tags/linux/" style="font-size: 13.33px;">linux</a> <a href="/tags/操作系统/" style="font-size: 16.67px;">操作系统</a> <a href="/tags/数字图像处理/" style="font-size: 20px;">数字图像处理</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">四月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">三月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">八月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/04/03/OS-处理器管理（4）-线程及其实现/">OS--处理器管理（4）_线程及其实现</a>
          </li>
        
          <li>
            <a href="/2020/04/02/OS-处理器管理（3）-进程及其实现/">OS--处理器管理（3）_进程及其实现</a>
          </li>
        
          <li>
            <a href="/2020/03/30/OS-处理器管理（1）-中断技术/">OS--处理器管理（2）_中断技术</a>
          </li>
        
          <li>
            <a href="/2020/03/28/OS-处理器管理（1）-处理器状态/">OS--处理器管理（1）_处理器状态</a>
          </li>
        
          <li>
            <a href="/2020/03/27/OS-操作系统概论/">OS--操作系统概论</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 dwyane_dongxh<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
</body>
</html>